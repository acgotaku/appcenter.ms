"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const mc_fus_uploader_types_1 = require("./mc-fus-uploader-types");
const crypto = require("crypto");
const mc_fus_mime_types_1 = require("./mc-fus-mime-types");
// Build a worker from an anonymous function body
let blobURL;
if (URL.createObjectURL) {
    blobURL = URL.createObjectURL(new Blob([
        "(",
        function () {
            const mcfusWorker = this;
            const xhr = new XMLHttpRequest();
            mcfusWorker.Domain = "";
            mcfusWorker.onmessage = (evt) => {
                if (evt.data.Domain) {
                    mcfusWorker.Domain = evt.data.Domain;
                    return;
                }
                if (!evt.data.Chunk) {
                    return;
                }
                mcfusWorker.sendChunk(evt.data.Chunk, evt.data.ChunkNumber, evt.data.Url);
            };
            mcfusWorker.sendChunk = (chunk, chunkNumber, url) => {
                xhr.open("POST", mcfusWorker.Domain + "/" + url, true);
                xhr.onreadystatechange = function () {
                    if (this.readyState === this.DONE) {
                        const message = {
                            Error: true,
                            ChunkNumber: chunkNumber,
                        };
                        if (this.status >= 200 &&
                            this.status < 300 &&
                            this.responseText !== null &&
                            this.responseText.indexOf("<!DOCTYPE html>") < 0) {
                            const data = JSON.parse(this.responseText);
                            message.Error = data.Error;
                        }
                        mcfusWorker.postMessage(message);
                    }
                };
                xhr.onerror = () => {
                    mcfusWorker.postMessage({ Error: true, ChunkNumber: chunkNumber });
                };
                xhr.ontimeout = () => {
                    mcfusWorker.postMessage({ Error: true, ChunkNumber: chunkNumber });
                };
                //@ts-ignore
                //this check addresses a trailing zeros bug, where part of the chunk will be empty. Simply touching the size is enough to "fix" the problem
                const size = chunk.size;
                xhr.send(chunk);
            };
        }.toString(),
        ")()",
    ], { type: "application/javascript" }));
}
exports.McFusUploader = function (args) {
    const maxWorkerAgeInSeconds = 40;
    let ambiguousProgress = 0;
    let progressUpdateRate = 0;
    const maxNumberOfConcurrentUploads = 10;
    const uploadBaseUrls = {
        CancelUpload: "upload/cancel/",
        RestartUrl: "upload/restart/",
        SetMetadata: "upload/set_metadata/",
        UploadChunk: "upload/upload_chunk/",
        UploadFinished: "upload/finished/",
        UploadStatus: "upload/status/",
    };
    const uploadData = {
        AssetId: "00000000-0000-0000-0000-000000000000",
        BlobPartitions: 0,
        CallbackUrl: "",
        CorrelationId: "00000000-0000-0000-0000-000000000000",
        CorrelationVector: "",
        ChunkSize: 0,
        LogToConsole: false,
        Tenant: "",
        UrlEncodedToken: "",
        TotalBlocks: 0,
        UploadDomain: "",
        Uploaders: 8,
        WorkerScript: "",
    };
    // Exposed for testing.
    this.uploadData = uploadData;
    const uploadStatus = {
        AutoRetryCount: 0,
        AverageSpeed: 0,
        BlocksCompleted: 0,
        ChunksFailedCount: 0,
        ChunkQueue: [],
        Connected: true,
        EndTime: new Date(),
        HealthCheckRunning: false,
        InflightChunks: [],
        InflightSet: new Set(),
        RequestSet: new Set(),
        MaxErrorCount: 20,
        ServiceCallback: {
            AutoRetryCount: 5,
            AutoRetryDelay: 1,
            FailureCount: 0,
        },
        StartTime: new Date(),
        State: mc_fus_uploader_types_1.McFusUploadState.New,
        TransferQueueRate: [],
        UseSingleThreadUpload: false,
        Workers: [],
        WorkerErrorCount: 0,
    };
    // Exposed for testing.
    this.uploadStatus = uploadStatus;
    const eventHandlers = {
        onProgressChanged: (progress) => { },
        onCompleted: (uploadStats) => { },
        onResumeRestart: (onResumeStartParams) => { },
        onMessage: (message, properties, messageLevel) => { },
        onStateChanged: (state) => { },
        onNewXMLHttpRequest: () => new XMLHttpRequest(),
    };
    function calculateAverageSpeed() {
        if (uploadStatus.TransferQueueRate.length === 0) {
            return 0;
        }
        let rateSum = 0;
        for (const transferQueueRate of uploadStatus.TransferQueueRate) {
            rateSum += transferQueueRate;
        }
        return rateSum / uploadStatus.TransferQueueRate.length;
    }
    function calculateRate() {
        // Get the elapsed time in seconds
        const diff = new Date().getTime() - uploadStatus.StartTime.getTime();
        const seconds = diff / 1000;
        // Megabytes per second
        const speed = (uploadStatus.BlocksCompleted * uploadData.ChunkSize) / 1024 / 1024 / seconds;
        // Times 8 to convert bits to bytes
        const rate = speed * 8;
        return rate;
    }
    function calculateTimeRemaining() {
        // calculate time remaining using chunks to avoid hitting the disc for size
        const dataRemaining = uploadStatus.ChunkQueue.length * uploadData.ChunkSize;
        if (uploadStatus.AverageSpeed > 0 && dataRemaining > 0) {
            let timeInSeconds = (dataRemaining * 8) / (1024 * 1024 * uploadStatus.AverageSpeed);
            const hours = Math.floor(timeInSeconds / 60 / 60);
            timeInSeconds -= hours * 60 * 60;
            return timeInSeconds;
        }
        return 0;
    }
    function completeUpload() {
        // Only raise the completed event if we've not done it before, this can happen
        // due to a race condition on status checks calling finishUpload simultaneously
        if (uploadStatus.State === mc_fus_uploader_types_1.McFusUploadState.Completed) {
            return;
        }
        const rate = calculateRate();
        const diff = uploadStatus.EndTime.getTime() - uploadStatus.StartTime.getTime();
        const seconds = diff / 1000;
        const uploadStats = {
            AssetId: uploadData.AssetId,
            TotalTimeInSeconds: seconds.toFixed(1),
            AverageSpeedInMbps: rate,
        };
        setState(mc_fus_uploader_types_1.McFusUploadState.Completed);
        const completeMessage = "UploadCompleted: " +
            " Multithreaded: " +
            !useSingleThreadUploader() +
            " total time: " +
            uploadStats.TotalTimeInSeconds +
            " seconds. Average speed: " +
            uploadStats.AverageSpeedInMbps +
            " Mbps.";
        log(completeMessage, {
            UploadFileSize: uploadData.File.size,
            UploadSpeed: uploadStats.AverageSpeedInMbps,
            ElapsedSeconds: uploadStats.TotalTimeInSeconds,
        });
        eventHandlers.onCompleted(uploadStats);
    }
    function dispatchWorker(worker) {
        return __awaiter(this, void 0, void 0, function* () {
            // if we are done then call finished and return
            if (uploadStatus.ChunkQueue.length === 0) {
                removeWorker(worker);
                log("Worker finished.");
                return;
            }
            // if we are not uploading chunks there is nothing to do.
            if (uploadStatus.State !== mc_fus_uploader_types_1.McFusUploadState.Uploading) {
                return;
            }
            const chunkToSend = uploadStatus.ChunkQueue.shift();
            // If other worker beat us to grab a chunk we're done
            if (chunkToSend === undefined) {
                return;
            }
            // Otherwise just start processing and uploading the chunk
            const start = (chunkToSend - 1) * uploadData.ChunkSize;
            const end = Math.min(chunkToSend * uploadData.ChunkSize, uploadData.File.size);
            const chunk = uploadData.File.slice(start, end);
            const url = yield addMd5ToUrl(`${uploadBaseUrls.UploadChunk}${uploadData.AssetId}?block_number=${chunkToSend}&token=${uploadData.UrlEncodedToken}&correlation_id=${uploadData.CorrelationId}`, chunk);
            // Don't request if chunk is empty
            if (chunk.size === 0) {
                return;
            }
            worker.postMessage({
                Chunk: chunk,
                ChunkNumber: chunkToSend,
                Url: url,
                CorrelationVector: uploadData.CorrelationVector,
            });
            // Track the current chunk as in-flight.
            uploadStatus.InflightChunks.push(new mc_fus_uploader_types_1.InflightModelChunk(chunkToSend, worker));
        });
    }
    function blobToArrayBuffer(blob) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const fileReader = new FileReader();
                fileReader.onload = () => {
                    resolve(fileReader.result);
                };
                fileReader.readAsArrayBuffer(blob);
            });
        });
    }
    function addMd5ToUrl(url, chunk) {
        return __awaiter(this, void 0, void 0, function* () {
            const chunkBuffer = yield blobToArrayBuffer(chunk);
            const md5Crypto = crypto.createHash("md5");
            const md5Hash = encodeURIComponent(md5Crypto.update(Buffer.from(chunkBuffer)).digest("base64"));
            const result = url + `&md5=${md5Hash}`;
            return result;
        });
    }
    function enqueueChunks(chunks) {
        // if the queue is empty then just add all the chunks
        if (uploadStatus.ChunkQueue.length === 0) {
            uploadStatus.ChunkQueue = chunks;
            return;
        }
        // if there something in the queue, don't re-add a chunk. This
        // can result in more than one thread uploading the same chunk
        uploadStatus.ChunkQueue = uploadStatus.ChunkQueue.concat(chunks.filter(function (chunk) {
            return uploadStatus.ChunkQueue.indexOf(chunk) < 0;
        }));
    }
    function error(errorMessage, properties = {}, errorCode) {
        errorCode = errorCode || mc_fus_uploader_types_1.McFusUploadState.FatalError;
        setState(errorCode);
        properties.VerboseMessage = "Error Code: " + errorCode + " - " + errorMessage;
        log(errorMessage, properties, mc_fus_uploader_types_1.McFusMessageLevel.Error);
    }
    function finishUpload() {
        // Only verify the upload once at a time.
        if (uploadStatus.State === mc_fus_uploader_types_1.McFusUploadState.Verifying || uploadStatus.State === mc_fus_uploader_types_1.McFusUploadState.Completed) {
            return;
        }
        setState(mc_fus_uploader_types_1.McFusUploadState.Verifying);
        log("Verifying upload on server.");
        stopAllWorkers();
        sendRequest({
            type: "POST",
            async: true,
            useAuthentication: true,
            url: uploadBaseUrls.UploadFinished +
                encodeURIComponent(uploadData.AssetId) +
                "?callback=" +
                encodeURIComponent(uploadData.CallbackUrl),
            error: function (err) {
                log("Finalize upload failed. Trying to autorecover... " + err.message);
                setState(mc_fus_uploader_types_1.McFusUploadState.Uploading);
                healthCheck();
            },
            success: function (response) {
                // it's possible that the health check called complete before this method did.
                // Log the current status and proceed with response verification.
                if (uploadStatus.State !== mc_fus_uploader_types_1.McFusUploadState.Verifying) {
                    log("Verifying: Upload status has changed, current status: " + uploadStatus.State);
                }
                //if no error then execute callback
                if (response.error === false && response.state === "Done") {
                    log("UploadFinalized. McFus reported the upload as completed. Status message: " + response.message, {
                        location: response.location,
                    });
                    // Finally report upload completion.
                    completeUpload();
                    // Attempt to perform a callback
                    invokeCallback(response.raw_location);
                }
                else {
                    // if chunks are missing enqueue missing chunks
                    if (response.missing_chunks && response.missing_chunks.length > 0) {
                        // If there are missing chunks lets adjust the completed count.
                        uploadStatus.BlocksCompleted = uploadData.TotalBlocks - response.missing_chunks.length;
                        enqueueChunks(response.missing_chunks);
                        setState(mc_fus_uploader_types_1.McFusUploadState.Uploading);
                        log("Finalizing found missing " + response.missing_chunks.length + " chunks. Requeuing chunks.", {
                            ChunksMissing: response.missing_chunks,
                        });
                        if (useSingleThreadUploader()) {
                            for (let i = 0; i < Math.min(maxNumberOfConcurrentUploads, uploadStatus.ChunkQueue.length); i++) {
                                singleThreadedUpload();
                            }
                            return;
                        }
                        return;
                    }
                    // TODO: investigate if dead code.
                    // if no chunks are missing this must be an unhandled error
                    // display the details to the user and stop the upload.
                    error(response.message);
                }
            },
        });
    }
    function formatAsDoubleDigit(number) {
        return number >= 0 && number < 10 ? "0" + number : number;
    }
    function hasRequiredSettings(settings) {
        let hasSettings = true;
        if (!settings.AssetId) {
            hasSettings = false;
            error("An AssetId must be specified.");
        }
        if (!settings.UrlEncodedToken) {
            hasSettings = false;
            error("The upload UrlEncodedToken must be specified.");
        }
        if (!settings.UploadDomain) {
            hasSettings = false;
            error("The UploadDomain must be specified.");
        }
        if (!settings.Tenant) {
            hasSettings = false;
            error("The Tenant name must be specified.");
        }
        return hasSettings;
    }
    function healthCheck() {
        // Only allow one health check at a time.
        if (uploadStatus.HealthCheckRunning === true) {
            return;
        }
        if (useSingleThreadUploader()) {
            if (uploadStatus.Workers.length > 0) {
                stopAllWorkers();
            }
            else {
                setState(mc_fus_uploader_types_1.McFusUploadState.Uploading);
            }
            // Failing shows progress
            eventHandlers.onProgressChanged({ percentCompleted: ++ambiguousProgress, Rate: "", AverageSpeed: "", TimeRemaining: "" });
            log("Starting singleThreadedUpload with chunks: " + uploadStatus.ChunkQueue);
            for (let i = 0; i < Math.min(maxNumberOfConcurrentUploads, uploadStatus.ChunkQueue.length); i++) {
                singleThreadedUpload();
            }
            return;
        }
        uploadStatus.HealthCheckRunning = true;
        log("Health check: " + toTimeString(new Date()));
        // If the we are not uploading there's nothing to check.
        if (!isUploadInProgress()) {
            log("Upload is not in progress. Stopping health check.");
            uploadStatus.HealthCheckRunning = false;
            return;
        }
        // Look at the current queue and determine if there's pending work
        if (uploadStatus.ChunkQueue.length === 0 && uploadStatus.Workers.length === 0) {
            uploadStatus.EndTime = new Date();
            finishUpload();
        }
        else {
            // Calculate the current chunk age and see if it's considered as stale.
            const now = new Date();
            const stuckChunks = [];
            for (const inflightChunk of uploadStatus.InflightChunks) {
                // If a chunk has exceeded its maximum time to live we assume it has
                // become stale, proceed to terminate it and create a replacement
                const ageInSeconds = (now.getTime() - inflightChunk.getStarted().getTime()) / 1000;
                if (ageInSeconds > maxWorkerAgeInSeconds) {
                    stuckChunks.push(inflightChunk);
                }
            }
            if (stuckChunks.length > 0) {
                // Failing shows progress
                eventHandlers.onProgressChanged({ percentCompleted: ++ambiguousProgress, Rate: "", AverageSpeed: "", TimeRemaining: "" });
                for (const stuckChunk of stuckChunks) {
                    // Keep track of the amount of replaced workers.
                    uploadStatus.WorkerErrorCount++;
                    removeInflightChunk(stuckChunk.getChunkNumber());
                    enqueueChunks([stuckChunk.getChunkNumber()]);
                    // Replace the stuck worker with a new one.
                    removeWorker(stuckChunk.getWorker());
                    startWorker();
                }
            }
        }
        if (uploadStatus.Workers.length === 0 && uploadStatus.ChunkQueue.length > 0) {
            initWorkers();
        }
        uploadStatus.HealthCheckRunning = false;
        setTimeout(healthCheck, 5 * 1000);
    }
    function hookupEventListeners(settings) {
        eventHandlers.onProgressChanged = settings.onProgressChanged;
        eventHandlers.onCompleted = settings.onCompleted;
        eventHandlers.onResumeRestart = settings.onResumeRestart;
        eventHandlers.onMessage = settings.onMessage;
        eventHandlers.onStateChanged = settings.onStateChanged;
        if (settings.onNewXMLHttpRequest) {
            eventHandlers.onNewXMLHttpRequest = settings.onNewXMLHttpRequest;
        }
    }
    function initializeUpload(settings) {
        // Validate required arguments if any
        // is missing the upload will fail.
        if (!hasRequiredSettings(settings)) {
            return;
        }
        // Validate optional arguments if not
        // provided we fallback to defaults.
        processOptionalSettings(settings);
        // Hookup all the event user defined event handlers.
        hookupEventListeners(settings);
        // Make sure browser supports all required features.
        if (!isBrowserSupported()) {
            setState(mc_fus_uploader_types_1.McFusUploadState.Error);
        }
        // After all checks have completed finally proceed
        // to initialize all the upload required fields.
        setState(mc_fus_uploader_types_1.McFusUploadState.New);
        // Initialize all retry flags for the new upload.
        uploadStatus.AutoRetryCount = 3;
        uploadStatus.BlocksCompleted = 0;
        uploadStatus.ServiceCallback.AutoRetryCount = 5;
        uploadStatus.ServiceCallback.AutoRetryDelay = 1;
        uploadStatus.ServiceCallback.FailureCount = 0;
        uploadStatus.WorkerErrorCount = 0;
        uploadStatus.HealthCheckRunning = false;
        // Copy all the required settings on to the upload data.
        uploadData.AssetId = settings.AssetId;
        uploadData.UploadDomain = settings.UploadDomain;
        uploadData.UrlEncodedToken = settings.UrlEncodedToken;
        uploadData.Tenant = settings.Tenant;
        log("Upload created");
    }
    function initWorkers() {
        // Mark the current upload as in progress
        setState(mc_fus_uploader_types_1.McFusUploadState.Uploading);
        // Kill all existing workers (if any)
        if (uploadStatus.Workers.length > 0) {
            stopAllWorkers();
        }
        // Calculate the number of worker threads to use
        log("# of workers needed: " + uploadStatus.ChunkQueue.length);
        const numberOfWorkers = Math.min(uploadData.Uploaders, uploadStatus.ChunkQueue.length);
        for (let i = 0; i < numberOfWorkers; i++) {
            // Stagger worker creation to avoid startup contention
            startWorker();
        }
    }
    function invokeCallback(location) {
        if (uploadData.CallbackUrl && uploadData.CallbackUrl !== "") {
            const callbackUrl = uploadData.CallbackUrl +
                "/" +
                encodeURIComponent(uploadData.AssetId) +
                "?file_name=" +
                encodeURIComponent(uploadData.File.name) +
                "&file_size=" +
                encodeURIComponent(uploadData.File.size) +
                "&location=" +
                location;
            log("Callback was supplied. Invoking callback on: " + callbackUrl);
            sendRequest({
                type: "POST",
                url: callbackUrl,
                async: true,
                useBaseDomain: false,
                useAuthentication: false,
                error: function (response) {
                    const errorMessage = "Callback failed. Status: " + response.currentTarget.status;
                    // Non-fatal error, just log info
                    log(errorMessage, { FailedCallback: uploadData.CallbackUrl });
                    // If we still have retries available go ahead with the success callback.
                    if (uploadStatus.ServiceCallback.AutoRetryCount > 0) {
                        setTimeout(function () {
                            invokeCallback(location);
                        }, uploadStatus.ServiceCallback.AutoRetryDelay * 10);
                        uploadStatus.ServiceCallback.AutoRetryCount--;
                        uploadStatus.ServiceCallback.FailureCount++;
                        // Increment the backoff in multiples of 5 for
                        // subsequent attempts. (5, 25, 125 and so on)
                        uploadStatus.ServiceCallback.AutoRetryDelay *= 5;
                    }
                    else {
                        log("Callback retries depleted. The upload completed but the uploader was unable to perform a successful callback notifying completion.");
                    }
                },
                success: function () {
                    log("Callback succeeded.");
                },
            });
        }
    }
    function isBrowserSupported() {
        let isSupported = true;
        // Detect browser support for web workers.
        if (typeof Worker === "undefined") {
            error("Browser does not support web workers", {}, mc_fus_uploader_types_1.McFusUploadState.Error);
            isSupported = false;
        }
        // Detect browser support for file API.
        if (typeof window.File === "undefined") {
            error("Browser does not support the html 5 file api.", {}, mc_fus_uploader_types_1.McFusUploadState.Error);
            isSupported = false;
        }
        return isSupported;
    }
    function isUploadInProgress() {
        return (uploadStatus.State === mc_fus_uploader_types_1.McFusUploadState.Initialized ||
            uploadStatus.State === mc_fus_uploader_types_1.McFusUploadState.Uploading ||
            uploadStatus.State === mc_fus_uploader_types_1.McFusUploadState.Verifying);
    }
    function log(message, properties = {}, level = mc_fus_uploader_types_1.McFusMessageLevel.Information) {
        properties.VerboseMessage = "mc-fus-uploader - " + (properties.VerboseMessage ? properties.VerboseMessage : message);
        properties = getLoggingProperties(properties);
        if (window.console && uploadData.LogToConsole === true) {
            if (level === mc_fus_uploader_types_1.McFusMessageLevel.Error) {
                console.error(message, properties, level);
            }
            else {
                console.log(message, properties, level);
            }
        }
        eventHandlers.onMessage(message, properties, level);
    }
    function processOptionalSettings(settings) {
        uploadData.CallbackUrl = settings.CallbackUrl ? decodeURI(settings.CallbackUrl) : "";
        uploadData.CorrelationId = settings.CorrelationId || settings.AssetId;
        uploadData.CorrelationVector = settings.CorrelationVector || "";
        uploadData.LogToConsole = settings.LogToConsole || false;
        uploadData.Uploaders = settings.Uploaders || 8;
        uploadData.WorkerScript = settings.WorkerScript || "/js/worker.js";
    }
    function removeInflightChunk(chunkNumber) {
        for (let i = 0; i < uploadStatus.InflightChunks.length; i++) {
            if (uploadStatus.InflightChunks[i].getChunkNumber() === chunkNumber) {
                uploadStatus.InflightChunks.splice(i, 1);
                break;
            }
        }
    }
    function removeWorker(worker) {
        for (let i = 0; i < uploadStatus.Workers.length; i++) {
            if (worker === uploadStatus.Workers[i]) {
                worker.terminate();
                uploadStatus.Workers.splice(i, 1);
                break;
            }
        }
    }
    function reportProgress() {
        let percentCompleted = (uploadStatus.BlocksCompleted * 100) / uploadData.TotalBlocks;
        // Since workers that are on async processes can't be aborted there is a chance
        // that a chunk will be inflight and account as missing so when it gets resent
        // it will get accounted twice, since accounting for inflight chunks on the percentage
        // calculation is not reliable if we go over 100 we'll just mark it as 99.99.
        if (percentCompleted > 100) {
            percentCompleted = 99;
        }
        ambiguousProgress = Math.max(ambiguousProgress, percentCompleted);
        const rate = calculateRate();
        uploadStatus.TransferQueueRate.push(rate);
        if (uploadStatus.TransferQueueRate.length > 100) {
            uploadStatus.TransferQueueRate.shift();
        }
        uploadStatus.AverageSpeed = calculateAverageSpeed();
        const progress = {
            percentCompleted: percentCompleted,
            Rate: rate.toFixed(2),
            AverageSpeed: uploadStatus.AverageSpeed.toFixed(0),
            TimeRemaining: calculateTimeRemaining().toFixed(0),
        };
        eventHandlers.onProgressChanged(progress);
    }
    function sendRequest(requestOptions) {
        const xhr = eventHandlers.onNewXMLHttpRequest();
        // Check if the caller specifies a fully qualified url
        // or if it needs the McFus base domain to be appended.
        let requestUrl;
        if (requestOptions.useBaseDomain === false) {
            requestUrl = requestOptions.url;
        }
        else {
            requestUrl = uploadData.UploadDomain + "/" + requestOptions.url;
        }
        // All the call requires auth then we add the McFus token
        if (requestOptions.useAuthentication && requestOptions.useAuthentication === true) {
            if (requestUrl.indexOf("?") > 0) {
                requestUrl += "&";
            }
            else {
                requestUrl += "?";
            }
            requestUrl += `token=${uploadData.UrlEncodedToken}`;
        }
        // If cache is disabled we add a timestamp to the url.
        if (requestOptions.cache !== undefined && requestOptions.cache === false) {
            requestUrl += "&_=" + new Date().getTime();
        }
        // Make sure all requests have a CorrelationId
        requestUrl += `&correlation_id=${uploadData.CorrelationId}`;
        xhr.open(requestOptions.type, requestUrl, requestOptions.async);
        xhr.onreadystatechange = function (event) {
            if (xhr.readyState === 4) {
                const target = event.target;
                if (xhr.status >= 200 && xhr.status < 300 && target.responseText.indexOf("<!DOCTYPE html>") < 0) {
                    // All 2xxs with JSON only are considered to be successful calls.
                    if (requestOptions.success) {
                        const data = JSON.parse(target.responseText);
                        requestOptions.success(data);
                    }
                }
                else {
                    // Any other status code or if the page has markup it is
                    // considered as failed and invokes to the error callback.
                    if (requestOptions.error) {
                        requestOptions.error(event);
                    }
                }
                // No matter what we always call the completed callback if present.
                if (requestOptions.completed) {
                    requestOptions.completed(xhr.status);
                }
            }
        };
        xhr.onloadend = () => {
            uploadStatus.RequestSet.delete(xhr);
        };
        uploadStatus.RequestSet.add(xhr);
        if (requestOptions.chunk) {
            // @ts-ignore
            // this check addresses a trailing zeros bug, where part of the chunk will be empty. Simply touching the size is enough to "fix" the problem
            const size = requestOptions.chunk.size;
            xhr.send(requestOptions.chunk);
        }
        else {
            xhr.send();
        }
    }
    function setMetadata() {
        eventHandlers.onProgressChanged({ percentCompleted: ++ambiguousProgress, Rate: "", AverageSpeed: "", TimeRemaining: "" });
        const logProperties = {
            fileName: uploadData.File.name,
            fileSize: uploadData.File.size,
        };
        log("Setting Metadata.", logProperties);
        const fileExt = uploadData.File.name.split(".").pop();
        const mimeTypeParam = mc_fus_mime_types_1.default[fileExt] ? `&content_type=${encodeURIComponent(mc_fus_mime_types_1.default[fileExt])}` : ``;
        sendRequest({
            type: "POST",
            async: true,
            useAuthentication: true,
            url: uploadBaseUrls.SetMetadata +
                encodeURIComponent(uploadData.AssetId) +
                "?file_name=" +
                encodeURIComponent(uploadData.File.name) +
                "&file_size=" +
                encodeURIComponent(uploadData.File.size) +
                mimeTypeParam,
            error: function (response) {
                Object.assign(logProperties, {
                    StatusCode: response.currentTarget.status,
                    StatusText: response.currentTarget.statusText,
                });
                if (response.currentTarget.status === 0) {
                    error("Upload Failed. No network detected. Please try again.", {}, mc_fus_uploader_types_1.McFusUploadState.Error);
                }
                else {
                    error("The asset cannot be uploaded. Try creating a new one.", logProperties);
                }
            },
            success: function (response) {
                eventHandlers.onProgressChanged({ percentCompleted: ++ambiguousProgress, Rate: "", AverageSpeed: "", TimeRemaining: "" });
                // if we get an html document back we likely have a server error so report it and stop
                if (response.error === undefined && response.toString().indexOf("<!DOCTYPE html>") === 0) {
                    //strip off everything outside the body tags
                    const body = response.replace(/^[\S\s]*<body[^>]*?>/i, "").replace(/<\/body[\S\s]*$/i, "");
                    error(body);
                    return;
                }
                // Probably dead code - unable to return error body for 200 status code
                if (response.error) {
                    Object.assign(logProperties, {
                        StatusCode: response.currentTarget.status,
                        StatusText: response.currentTarget.statusText,
                    });
                    error(response.message, logProperties);
                    return;
                }
                Object.assign(logProperties, { serverLocation: response.server_location, chunkSize: response.chunk_size });
                log("Set metadata completed.", logProperties);
                uploadData.ChunkSize = response.chunk_size;
                uploadData.BlobPartitions = response.blob_partitions;
                // Calculate the number of chunks to send
                uploadData.TotalBlocks = Math.ceil(uploadData.File.size / uploadData.ChunkSize);
                progressUpdateRate = Math.ceil(uploadData.TotalBlocks / 100);
                log("Chunks to upload: " + uploadData.TotalBlocks);
                enqueueChunks(response.chunk_list);
                // Handle the restart/resume/recovery scenario
                if (response.resume_restart) {
                    setState(mc_fus_uploader_types_1.McFusUploadState.ResumeOrRestart);
                    const remainingChunksToUpload = response.chunk_list.length;
                    log("Chunks remaining to upload: " + remainingChunksToUpload);
                    uploadStatus.BlocksCompleted = uploadData.TotalBlocks - remainingChunksToUpload;
                    eventHandlers.onResumeRestart({ NumberOfChunksRemaining: remainingChunksToUpload });
                }
                else {
                    uploadStatus.BlocksCompleted = 0;
                    uploadStatus.StartTime = new Date();
                    healthCheck();
                }
            },
        });
    }
    function setState(state) {
        uploadStatus.State = state;
        log("Setting state: " + state);
        eventHandlers.onStateChanged(state);
    }
    function setupWorker() {
        let worker;
        try {
            worker = new Worker(blobURL || uploadData.WorkerScript);
        }
        catch (err) {
            // Current versions of Safari won't allow the blob script.
            log("Browser cannot create workers from blob. Falling back to single thread upload.");
            uploadStatus.UseSingleThreadUpload = true;
            return;
        }
        worker.postMessage({ Domain: uploadData.UploadDomain });
        worker.onmessage = function (msg) {
            if (msg.data.Error === true) {
                // Keep track of the amount of replaced workers.
                uploadStatus.WorkerErrorCount++;
                // The chunk was not uploaded successfully
                // get it back on the queue for retry
                enqueueChunks([msg.data.ChunkNumber]);
                log("Upload for chunk #: " + msg.data.ChunkNumber + " failed and will be retried.");
            }
            else {
                removeInflightChunk(msg.data.ChunkNumber);
                // Successful upload, mark completion and discard the chunk.
                uploadStatus.BlocksCompleted++;
                if (uploadStatus.BlocksCompleted % progressUpdateRate === 0) {
                    reportProgress();
                }
            }
            // Dispatch the worker instance again to keep processing
            dispatchWorker(worker).catch((errorMessage) => error(errorMessage));
        };
        worker.onerror = function () {
            //chunk data is lost, as is chunk number, relying on the finalize to catch this
            log("Worker crashed. Recovering...");
            // Dispatch the worker instance again to keep processing
            dispatchWorker(worker).catch((errorMessage) => error(errorMessage));
        };
        return worker;
    }
    function singleThreadedUpload() {
        if (uploadStatus.ChunkQueue.length === 0 && uploadStatus.InflightSet.size === 0) {
            uploadStatus.EndTime = new Date();
            finishUpload();
            return;
        }
        if (uploadStatus.ChunksFailedCount > uploadStatus.MaxErrorCount) {
            if (uploadStatus.State === mc_fus_uploader_types_1.McFusUploadState.Uploading) {
                // Treat client disconnect errors as non-fatal errors as a service health indicator.
                if (uploadStatus.Connected) {
                    error("Upload Failed. Encountered too many errors while uploading. Please try again.");
                }
                else {
                    error("Upload Failed. No network detected. Please try again.", {}, mc_fus_uploader_types_1.McFusUploadState.Error);
                }
            }
            // Cancel any single threaded operations.
            abortSingleThreadedUploads();
            return;
        }
        const chunkNumber = uploadStatus.ChunkQueue.pop();
        // Safety check in case the queue got emptied before or is still in flight.
        if (chunkNumber === undefined || uploadStatus.InflightSet.has(chunkNumber)) {
            return;
        }
        // Otherwise just start processing and uploading the chunk
        const start = (chunkNumber - 1) * uploadData.ChunkSize;
        const end = Math.min(chunkNumber * uploadData.ChunkSize, uploadData.File.size);
        const chunk = uploadData.File.slice(start, end);
        // Don't request if chunk is empty or in the wrong state
        if (chunk.size === 0 || uploadStatus.State !== mc_fus_uploader_types_1.McFusUploadState.Uploading) {
            return;
        }
        uploadChunk(chunk, chunkNumber).catch((errorMessage) => error(errorMessage));
    }
    function startWorker() {
        setTimeout(function () {
            const worker = setupWorker();
            if (!worker) {
                return;
            }
            // add the new worker to the pool
            uploadStatus.Workers.push(worker);
            log("Worker started at: " + toTimeString(new Date()));
            // start the upload process on the worker
            dispatchWorker(worker).catch((errorMessage) => error(errorMessage));
        }, 20);
    }
    function stopAllWorkers() {
        log("Stopping all workers.");
        // Tell all workers to abort their calls and close.
        for (const worker of uploadStatus.Workers) {
            worker.terminate();
        }
        // Once all workers have stopped lets reset the collection.
        enqueueChunks(uploadStatus.InflightChunks.map((chunk) => chunk.getChunkNumber()));
        uploadStatus.Workers = [];
        uploadStatus.InflightChunks = [];
    }
    function abortSingleThreadedUploads() {
        // Cancel any single threaded operations.
        uploadStatus.RequestSet.forEach((request) => {
            request.abort();
        });
    }
    function toTimeString(date) {
        return (formatAsDoubleDigit(date.getHours()) +
            ":" +
            formatAsDoubleDigit(date.getMinutes()) +
            ":" +
            formatAsDoubleDigit(date.getSeconds()) +
            "." +
            formatAsDoubleDigit(date.getMilliseconds()));
    }
    function getLoggingProperties(data) {
        const properties = {
            AssetId: uploadData.AssetId,
            CorrelationId: uploadData.CorrelationId,
            Tenant: uploadData.Tenant,
        };
        Object.assign(properties, data);
        return properties;
    }
    function uploadChunk(chunk, chunkNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            uploadStatus.InflightSet.add(chunkNumber);
            log("Starting upload for chunk: " + chunkNumber);
            sendRequest({
                type: "POST",
                async: true,
                useAuthentication: true,
                chunk: chunk,
                url: yield addMd5ToUrl(uploadBaseUrls.UploadChunk + encodeURIComponent(uploadData.AssetId) + "?block_number=" + chunkNumber, chunk),
                error: function (response) {
                    uploadStatus.InflightSet.delete(chunkNumber);
                    uploadChunkErrorHandler(response, chunkNumber);
                },
                success: function (response) {
                    uploadStatus.InflightSet.delete(chunkNumber);
                    if (response.error) {
                        uploadChunkErrorHandler(response, chunkNumber);
                        return;
                    }
                    else {
                        // If a user is struggling to upload, we can increase the MaxErrorCount on each success in order to keep trying while they are making some progress.
                        ++uploadStatus.MaxErrorCount;
                        uploadStatus.Connected = true;
                        log("ChunkSucceeded: " + chunkNumber + ".");
                        if (++uploadStatus.BlocksCompleted % progressUpdateRate === 0) {
                            reportProgress();
                        }
                    }
                    singleThreadedUpload();
                },
            });
        });
    }
    function uploadChunkErrorHandler(response, chunkNumber) {
        ++uploadStatus.ChunksFailedCount;
        log("ChunkFailed: " + chunkNumber + ".", {
            StatusCode: response.currentTarget.status,
            StatusText: response.currentTarget.statusText,
        });
        uploadStatus.ChunkQueue.push(chunkNumber);
        // If the user has gone offline, use a timeout for retrying instead
        if (response.currentTarget.status === 0) {
            uploadStatus.Connected = false;
            log("No network detected. Attempting chunk upload again in 10s.");
            setTimeout(() => {
                singleThreadedUpload();
            }, 1000 * 10 /* 10 seconds */);
        }
        else {
            uploadStatus.Connected = true;
            singleThreadedUpload();
        }
    }
    function useSingleThreadUploader() {
        // The uploader switches to single threaded under these conditions:
        // 1. The browser is incompatible.
        // 2. The upload has recovered too many workers.
        return ((window && window.navigator && window.navigator.userAgent.indexOf("Edge") > -1) ||
            uploadStatus.WorkerErrorCount > uploadStatus.MaxErrorCount ||
            uploadStatus.UseSingleThreadUpload);
    }
    this.Start = function (file) {
        if (!file || file.size <= 0) {
            error("A file must be specified and must not be empty.", {}, mc_fus_uploader_types_1.McFusUploadState.Error);
            return;
        }
        if (isUploadInProgress()) {
            // Non fatal error. Introducing a warning level is an API breaking change in portal. error() changes state.
            log("Cannot start an upload that is already in progress.", undefined, mc_fus_uploader_types_1.McFusMessageLevel.Error);
            return;
        }
        uploadData.File = file;
        setState(mc_fus_uploader_types_1.McFusUploadState.Initialized);
        setMetadata();
    };
    this.Restart = function () {
        log("UploadRestarted");
        sendRequest({
            type: "POST",
            async: true,
            useAuthentication: true,
            url: uploadBaseUrls.RestartUrl + encodeURIComponent(uploadData.AssetId),
            success: function (response) {
                if (response.error) {
                    error(response.message);
                    return;
                }
                setState(mc_fus_uploader_types_1.McFusUploadState.Uploading);
                uploadStatus.StartTime = new Date();
                healthCheck();
            },
        });
    };
    this.Pause = function () {
        if (!isUploadInProgress()) {
            error("Cannot pause an upload that is not in progress.");
            return;
        }
        log("UploadPaused");
        setState(mc_fus_uploader_types_1.McFusUploadState.Paused);
    };
    this.Continue = function () {
        if (uploadStatus.State !== mc_fus_uploader_types_1.McFusUploadState.Paused) {
            error("Cannot resume and upload that is not paused.");
            return;
        }
        log("UploadContinued");
        setState(mc_fus_uploader_types_1.McFusUploadState.Uploading);
        for (const worker of uploadStatus.Workers) {
            dispatchWorker(worker).catch((errorMessage) => error(errorMessage));
        }
        healthCheck();
    };
    this.Cancel = function () {
        log("UploadCancelled");
        sendRequest({
            type: "POST",
            async: true,
            useAuthentication: true,
            url: uploadBaseUrls.CancelUpload + encodeURIComponent(uploadData.AssetId),
            success: function (response) {
                log(response.message);
                setState(mc_fus_uploader_types_1.McFusUploadState.Cancelled);
                stopAllWorkers();
                abortSingleThreadedUploads();
            },
        });
    };
    this.Reset = function (settings) {
        initializeUpload(settings);
    };
    initializeUpload(args);
};
//# sourceMappingURL=mc-fus-uploader.js.map