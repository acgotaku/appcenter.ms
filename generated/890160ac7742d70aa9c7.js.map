{"version":3,"sources":["webpack:///./client/lib/http/fetch-error.ts","webpack:///./client/lib/http/params-parser-utils.ts","webpack:///./client/lib/http/index.ts","webpack:///./client/lib/i18n/i18n.ts","webpack:///./client/lib/i18n/date-formatter.ts","webpack:///./client/lib/i18n/index.ts","webpack:///./client/lib/i18n/utils.ts","webpack:///./client/lib/i18n/number-formatter.ts","webpack:///./client/lib/drag-drop-upload.ts","webpack:///./client/lib/http/get-token.ts","webpack:///./client/lib/http/timer.ts","webpack:///./client/lib/http/redirect-to-login-utils.ts","webpack:///./client/lib/i18n/webpack-backend.ts","webpack:///./client/lib/i18n/local-storage-language-detector.ts","webpack:///./client/lib/i18n/i18next-formatter.ts","webpack:///./client/lib/http/utils.ts","webpack:///./client/lib/http/http-client.ts"],"names":["getErrorMessage","httpResponse","body","error","message","statusText","Object","setPrototypeOf","FetchError","prototype","stack","this","status","code","Error","name","parse","path","params","retainUnusedParamsAsQuery","trim","length","pathChunks","split","pathChunksWithParams","map","chunk","index","startsWith","_paramPrefix","_alternativePrefix","endsWith","_alternativeSuffix","paramKey","substr","trimStart","trimEnd","matchingParamValue","Array","isArray","encodeURIComponent","join","queryParams","forOwn","value","key","forEach","v","push","ParamsParserUtils","detector","LocalStorageDetector","i18nTestHackSadFace","i18next","default","use","webpackBackend","init","fallbackLng","ns","defaultNS","load","debug","react","useSuspense","interpolation","escapeValue","format","FormatNumbersAndDates","t","bind","NumericOptions","StringOptions","MonthOptions","TimeZoneOptions","DateFormat","shortFullDate","month","Short","year","Numeric","day","shortFullDateNoCurrentYear","shortFullDateTime","hour","minute","second","shortFullDateTimeNoSeconds","shortFullDateTimeNoCurrentYear","shortMonthAndDate","TwoDigit","shortMonthAndShortDate","shortTime","shortMonthAndDateAndTime","full24HourTime","hour12","longFullDateTime","Long","longFullDateTimeWithSecondsAndWeekday","weekday","longFullMonthYear","longMonthAndDate","longMonthAndDateWithTimezone","timeZoneName","parts","hasOwnProperty","date","language","global","Intl","toString","options","timeZone","getFormatOptions","getFullYear","Date","DateTimeFormat","untyped","languages","NumberStyleOptions","CurrencyDisplayOptions","NumberFormat","standard","style","Decimal","useGrouping","minimumFractionDigits","grouped","decimal","maximumFractionDigits","currency","Currency","currencyDisplay","Symbol","percent","Percent","percentFixed","formatName","currencyOpts","digits","Number","parseInt","number","ProgressBarStatus","UploadStatus","token","authEndpoint","fetchToken","correlationId","uuid","v4","telemetryProperties","method","routePath","statusCode","duration","Utils","isIe","nocache","randomCacheBusterValue","undefined","start","Timer","startLap","headers","Headers","append","fetch","credentials","then","response","endLapAndTrack","ok","json","getToken","forceRefreshToken","getCurrentToken","expiration","parseISO","expirationTime","now","isAfter","addMinutes","catch","err","HttpTokenUtils","startInMs","getTime","lap","properties","endInMs","logger","info","metrics","emitMetric","returnToCurrentLocation","URLSearchParams","window","location","pathname","search","returnUrl","href","replaceLeaves","object","result","keys","type","services","backendOptions","defaultLocale","read","namespace","callback","cb","content","WebpackI18nextBackend","storageManager","StorageManager","detectorOptions","i18nextOptions","detect","lng","getObject","cleanedLng","languageUtils","formatLanguageCode","isSupportedCode","cacheUserLanguage","saveObject","isNumberFormat","formatLocalizedNumber","isDateFormat","formatLocalizedDate","parsedDate","toDate","isValid","navigator","appVersion","match","isInstallSubdomain","initProps","hostname","indexOf","InstallSubdomainPrefix","forceSubdomain","InstallSubdomain","valueOf","random","METHODS","HEAD","GET","POST","PATCH","PUT","DELETE","rootUrl","_rootUrl","head","url","_call","get","post","put","patch","delete","call","parsedUrl","Url","protocol","host","noCacheParam","assign","requestOptions","upperCase","noJson","defaultBody","JSON","stringify","me","prepareForFetch","Promise","resolve","noBifrostToken","has","jwtToken","logoutToSignIn","_fetch","responseType","RESPONSE_TYPES","text","exception","HttpClient","apiGateway","config","getApiGatewayUrlInstall","getApiGatewayUrl","accountManagementHttpClient","getAccountManagementUrl","portalServer"],"mappings":"0jBAEA,SAASA,EAAgBC,EAAmBC,GAC1C,OAAIA,GAAQA,EAAKC,OAASD,EAAKC,MAAMC,QAC5BF,EAAKC,MAAMC,QACTF,GAAQA,EAAKE,QACfF,EAAKE,QAELH,EAAaI,YAAcJ,EAAaG,OAEnD,C,qEAVA,OAeA,kBACE,WAAmBH,EAA0BC,GAA7C,MAGE,YAAMF,EAAgBC,EAAcC,KAAM,K,OAHzB,EAAAD,eAA0B,EAAAC,OAK3CI,OAAOC,eAAe,EAAMC,EAAWC,WACvC,EAAKC,MAAQT,EAAaS,OAAUR,GAAQA,EAAKQ,M,CACnD,CA+CF,OAvDgC,OAa9B,sBAAI,sBAAO,C,IAAX,WAGE,OAAOV,EAAgBW,KAAKV,aAAcU,KAAKT,KACjD,E,gCAKA,sBAAI,qBAAM,C,IAAV,WACE,OAAOS,KAAKV,aAAaW,MAC3B,E,gCAKA,sBAAI,yBAAU,C,IAAd,WACE,OAAOD,KAAKV,aAAaI,UAC3B,E,gCAKA,sBAAI,mBAAI,C,IAAR,WACE,OAAIM,KAAKT,MAAQS,KAAKT,KAAKC,OAASQ,KAAKT,KAAKC,MAAMU,KAC3CF,KAAKT,KAAKC,MAAMU,UAEvB,CAEJ,E,gCAOA,sBAAI,mBAAI,C,IAAR,WACE,IAAMV,EAAQ,IAAIW,MAAMH,KAAKP,SAG7B,OAFAD,EAAMO,MAAQC,KAAKD,MACnBP,EAAMY,KAAOJ,KAAKI,KACXZ,CACT,E,gCACF,EAvDA,CAAgCW,OAAnB,EAAAN,Y,wVCfb,WASA,0BAgGA,QAhEgB,EAAAQ,MAAd,SAAoBC,EAAcC,EAAgCC,GAAlE,WAEE,QAFgE,IAAAA,OAAA,GAE5C,KADpBF,GAAO,IAAAG,MAAKH,IACHI,OACP,MAAO,GAGT,IAAMC,EAAaL,EAAKM,MAAM,KAG9BL,EAAS,EAAH,GAAQA,GAGd,IAAMM,EAAuBF,EAAWG,KAAI,SAACC,EAAeC,GAC1D,IAAKD,GAA0B,IAAjBA,EAAML,OAClB,OAAOK,EAKT,GAFAA,GAAQ,IAAAN,MAAKM,IAGX,IAAAE,YAAWF,EAAO,EAAKG,gBACtB,IAAAD,YAAWF,EAAO,EAAKI,sBAAuB,IAAAC,UAASL,EAAO,EAAKM,oBACpE,CACA,IAAIC,OAAQ,GACR,IAAAL,YAAWF,EAAO,EAAKG,cACzBI,EAAWP,EAAMQ,OAAO,EAAKL,aAAaR,SAE1CY,GAAW,IAAAE,WAAUT,EAAO,EAAKI,oBACjCG,GAAW,IAAAG,SAAQH,EAAU,EAAKD,qBAGpC,IAAMK,EAAqBnB,EAAOe,GAGlC,QAAkC,IAAvBI,IAF0B,MAAvBA,GAAqD,OAAvBA,GAQ1C,cAJOnB,EAAOe,IAEcK,MAAMC,QAAQF,GAAsBA,EAAqB,CAACA,IAE3DZ,IAAIe,oBAAoBC,KAAK,I,CAI5D,OAAOf,CACT,IAGMgB,EAAwB,GAc9B,OAbIvB,IACF,IAAAwB,QAAOzB,GAAU,CAAC,GAAG,SAAC0B,EAAOC,IACZP,MAAMC,QAAQK,GAASA,EAAQ,CAACA,IACxCE,SAAQ,SAACC,GACdL,EAAYM,KAAK,UAAGH,EAAG,YAAIL,mBAAmBO,IAChD,GACF,IAIF9B,EAAOO,EAAqBiB,KAAK,KACjCxB,EAAOyB,EAAYrB,OAAS,EAAI,UAAGJ,EAAI,YAAIyB,EAAYD,KAAK,MAASxB,CAGvE,EA9Fe,EAAAY,aAAuB,IACvB,EAAAC,mBAA6B,IAC7B,EAAAE,mBAA6B,IA6F9C,C,CAhGA,GAAa,EAAAiB,mB,ugBCTb,W,+FCMA,aACA,SACA,SACA,SAEMC,EAAW,IAAI,EAAAC,qBAGjBC,EAAwDC,EAAQC,QAKpEF,EACGG,IAAI,EAAAC,gBACJD,IAAIL,GACJO,KAAK,CACJC,YAAa,QAGbC,GAAI,CAAC,UACLC,UAAW,SAGXC,KAAM,cAGNC,OAAO,EAGPC,MAAO,CACLC,aAAa,GAGfC,cAAe,CACbC,aAAa,EACbC,OAAQ,EAAAC,yBAId,UAAehB,EACF,EAAAiB,EAAuBjB,EAAoBiB,EAAEC,KAAKlB,E,oDC3C1DmB,EAKAC,EAMAC,EASAC,E,kUApBL,SAAKH,GACH,oBACA,oBACD,CAHD,CAAKA,MAAc,KAKnB,SAAKC,GACH,kBACA,gBACA,aACD,CAJD,CAAKA,MAAa,KAMlB,SAAKC,GACH,oBACA,qBACA,kBACA,gBACA,aACD,CAND,CAAKA,MAAY,KASjB,SAAKC,GACH,gBACA,aACD,CAHD,CAAKA,MAAe,KAsDpB,IAAMC,EAAiE,CACrEC,cAAe,CACbC,MAAOJ,EAAaK,MACpBC,KAAMR,EAAeS,QACrBC,IAAKV,EAAeS,SAEtBE,2BAA4B,CAC1BL,MAAOJ,EAAaK,MACpBC,KAAMR,EAAeS,QACrBC,IAAKV,EAAeS,SAEtBG,kBAAmB,CACjBN,MAAOJ,EAAaK,MACpBC,KAAMR,EAAeS,QACrBC,IAAKV,EAAeS,QACpBI,KAAMb,EAAeS,QACrBK,OAAQd,EAAeS,QACvBM,OAAQf,EAAeS,SAEzBO,2BAA4B,CAC1BV,MAAOJ,EAAaK,MACpBC,KAAMR,EAAeS,QACrBC,IAAKV,EAAeS,QACpBI,KAAMb,EAAeS,QACrBK,OAAQd,EAAeS,SAEzBQ,+BAAgC,CAC9BX,MAAOJ,EAAaK,MACpBC,KAAMR,EAAeS,QACrBC,IAAKV,EAAeS,QACpBI,KAAMb,EAAeS,QACrBK,OAAQd,EAAeS,SAEzBS,kBAAmB,CACjBZ,MAAOJ,EAAaK,MACpBG,IAAKV,EAAemB,UAEtBC,uBAAwB,CACtBd,MAAOJ,EAAaK,MACpBG,IAAKV,EAAeS,SAEtBY,UAAW,CACTR,KAAMb,EAAeS,QACrBK,OAAQd,EAAeS,SAEzBa,yBAA0B,CACxBhB,MAAOJ,EAAaK,MACpBG,IAAKV,EAAeS,QACpBI,KAAMb,EAAeS,QACrBK,OAAQd,EAAeS,SAEzBc,eAAgB,CACdV,KAAMb,EAAemB,SACrBL,OAAQd,EAAemB,SACvBJ,OAAQf,EAAemB,SACvBK,QAAQ,GAEVC,iBAAkB,CAChBnB,MAAOJ,EAAawB,KACpBlB,KAAMR,EAAeS,QACrBC,IAAKV,EAAeS,QACpBI,KAAMb,EAAeS,QACrBK,OAAQd,EAAeS,QACvBM,OAAQf,EAAeS,SAEzBkB,sCAAuC,CACrCC,QAAS3B,EAAcyB,KACvBpB,MAAOJ,EAAawB,KACpBhB,IAAKV,EAAeS,QACpBD,KAAMR,EAAeS,QACrBI,KAAMb,EAAeS,QACrBK,OAAQd,EAAeS,QACvBM,OAAQf,EAAeS,SAEzBoB,kBAAmB,CACjBvB,MAAOJ,EAAawB,KACpBlB,KAAMR,EAAeS,SAEvBqB,iBAAkB,CAChBxB,MAAOJ,EAAawB,KACpBhB,IAAKV,EAAeS,SAEtBsB,6BAA8B,CAC5BzB,MAAOJ,EAAawB,KACpBhB,IAAKV,EAAeS,QACpBuB,aAAc7B,EAAgBI,QASlC,wBAA6BX,GAC3B,IAAKA,EACH,OAAO,EAGT,IAAMqC,EAAQrC,EAAO5C,MAAM,KAC3B,OAAOoD,EAAW8B,eAAeD,EAAM,GACzC,EAoBA,+BAAoCE,EAAYvC,EAA8BwC,GAC5E,IAAKC,EAAOC,KAEV,OAAOH,EAAKI,WAKd,IAAIC,EA1BN,SAA0B5C,GACxB,IAAMqC,EAAQrC,EAAO5C,MAAM,KACrBwF,EAAsCpC,EAAW6B,EAAM,IAE7D,OAAqB,IAAjBA,EAAMnF,QAA6B,QAAbmF,EAAM,GACvB,EAAP,KAAYO,GAAO,CAAEC,SAAU,QAG1B,EAAP,GAAYD,EACd,CAiBgBE,CAAiB9C,GAS/B,MARe,mCAAXA,GAA0D,+BAAXA,GAC3BuC,EAAKQ,iBAAkB,IAAIC,MAAOD,sBAE/CH,EAAQhC,KAGD,IAAI8B,KAAKO,eAAeT,EAAUI,GAEnC5C,OAAOuC,EAC1B,C,0hBCzNA,YACA,YACA,YACA,YACA,YACA,YACA,W,gHCNA,aAKA,gCACE,IAAMW,EAAU,UAChB,OAAOA,GAAWA,EAAQ/D,SAAW+D,EAAQ/D,QAAQgE,WAAaD,EAAQ/D,QAAQgE,UAAUjG,OAAS,EACjGgG,EAAQ/D,QAAQgE,UAAU,GAC1B,OACN,C,oDCVKC,EAMAC,E,yVANL,SAAKD,GACH,oBACA,sBACA,mBACD,CAJD,CAAKA,MAAkB,KAMvB,SAAKC,GACH,kBACA,cACA,aACD,CAJD,CAAKA,MAAsB,KAW3B,IAAMC,EAAmE,CACvEC,SAAU,CACRC,MAAOJ,EAAmBK,QAC1BC,aAAa,EACbC,sBAAuB,GAEzBC,QAAS,CACPJ,MAAOJ,EAAmBK,QAC1BC,aAAa,EACbC,sBAAuB,GAEzBE,QAAS,CACPL,MAAOJ,EAAmBK,QAC1BC,aAAa,EACbC,sBAAuB,EACvBG,sBAAuB,GAEzBC,SAAU,CACRP,MAAOJ,EAAmBY,SAE1BC,gBAAiBZ,EAAuBa,QAE1CC,QAAS,CACPX,MAAOJ,EAAmBgB,SAE5BC,aAAc,CACZb,MAAOJ,EAAmBgB,UAkB9B,SAAgBtB,EAAiB9C,GAC/B,IAAMqC,EAAQrC,EAAO5C,MAAM,KACrBkH,EAAajC,EAAM,GACnBO,EAAoCU,EAAagB,GAGvD,GAAmB,aAAfA,EAA2B,CAC7B,IAAMC,EAAoB,CAAER,SAAU,OAKtC,OAJqB,IAAjB1B,EAAMnF,QAA6B,UAAbmF,EAAM,KAC9BkC,EAAaZ,sBAAwB,EACrCY,EAAaT,sBAAwB,GAEhC,EAAP,KAAYlB,GAAY2B,E,CACnB,IAAoB,YAAfD,GAA2C,iBAAfA,IAAmD,IAAjBjC,EAAMnF,OAAc,CAC5F,IAAMsH,EAASC,OAAOC,SAASrC,EAAM,GAAI,IACzC,OAAO,EAAP,KAAYO,GAAO,CAAEe,sBAAuBa,EAAQV,sBAAuBU,G,CACtE,IAAoB,YAAfF,GAA2C,YAAfA,IAA8C,IAAjBjC,EAAMnF,OAAc,CAEjFsH,EAASC,OAAOC,SAASrC,EAAM,GAAI,IACzC,OAAO,EAAP,KAAYO,GAAO,CAAEkB,sBAAuBU,G,CAG9C,OAAO,EAAP,GAAY5B,EACd,CAhCA,0BAA+B5C,GAC7B,IAAKA,EACH,OAAO,EAGT,IAAMqC,EAAQrC,EAAO5C,MAAM,KAC3B,OAAOkG,EAAahB,eAAeD,EAAM,GAC3C,EAEA,qBAiCA,iCAAsCsC,EAAgB3E,EAAuBwC,GAC3E,IAAKC,EAAOC,KAEV,OAAOiC,EAAOhC,WAEhB,IAAMC,EAAUE,EAAiB9C,GAIjC,OAFkB,IAAI0C,KAAKY,aAAad,EAAUI,GAEjC5C,OAAO2E,EAC1B,C,iJCtGA,SAAYC,GACV,yBACA,qCACA,oBACD,CAJD,CAAY,EAAAA,oBAAA,EAAAA,kBAAiB,KAM7B,SAAYC,GACV,qCACA,2CACA,+CACA,6CACA,mCACA,2CACA,0CACD,CARD,CAAY,EAAAA,eAAA,EAAAA,aAAY,I,qVCHxB,OACA,IAYIC,EAZJ,QACA,SACA,SACA,QACA,SACA,SASIC,EAAe,cAGnB,0BAsEA,QArEgB,EAAAC,WAAd,WACE,IAAMC,EAAgBC,EAAKC,KACrBC,EAAkD,CACtDC,OAAQ,MACRC,UAAWP,EACXQ,WAAY,UACZC,SAAU,EACVP,cAAa,GAGfF,EAAe,EAAAjG,kBAAkBjC,MAAMkI,EAAc,EAAF,GAC5C,EAAAU,MAAMC,QAAU,CAAEC,QAAS,EAAAF,MAAMG,gCAA+BC,IAEvE,IAAMC,EAAQ,EAAAC,MAAMC,WACdC,EAAU,IAAIC,QAGpB,OAFAD,EAAQE,OAAO,qBAAsBlB,GAE9BmB,MAAMrB,EAAc,CACzBM,OAAQ,MACRY,QAASA,EACTI,YAAa,YACZC,MACD,SAACC,GAIC,GAFA,EAAAR,MAAMS,eAAeV,EAAO,EAAF,KAAOV,GAAmB,CAAEG,WAAYgB,EAAS9J,OAAS,MAEhF8J,EAASE,GACX,OAAOF,EAASG,OAEhB,MAAM,IAAI,EAAArK,WAAWkK,EAEzB,IACA,SAACvK,GAIC,MAFA,EAAA+J,MAAMS,eAAeV,EAAO,EAAF,KAAOV,GAAmB,CAAEG,WAAY,WAE5D,IAAI,EAAAlJ,WAAWL,EACvB,GAEJ,EAEc,EAAA2K,SAAd,SAAuB/D,GAAvB,WACU,EAA8BA,EAAO,kBAArCgE,OAAiB,IAAG,GAAK,EAEjC,OAAOpK,KAAKqK,gBAAgBD,GACzBN,MAAK,SAACxB,GACL,IAAMgC,GAAa,IAAAC,UAASjC,EAAMkC,gBAC5BC,EAAM,IAAIjE,KAChB,OAAI,IAAAkE,UAAQ,IAAAC,YAAWF,EAnDQ,IAmD8BH,GAEpD,EAAKD,iBAAgB,GAGvB/B,CACT,IACCsC,OAAM,SAACC,GAIN,MAFAvC,OAAQe,EAEFwB,CACR,GACJ,EAEe,EAAAR,gBAAf,SAA+BD,GAI7B,OAHK9B,IAAS8B,IACZ9B,EAAQtI,KAAKwI,cAERF,CACT,EACF,EAtEA,GAAa,EAAAwC,gB,mGCvBb,YAqBA,0BAwBA,QAnBgB,EAAAtB,SAAd,WACE,MAAO,CAAEuB,WAAW,IAAIvE,MAAOwE,UACjC,EAEc,EAAAhB,eAAd,SAA6BiB,EAAUC,GACrCD,EAAIE,SAAU,IAAI3E,MAAOwE,UAEzB,IAAMhC,EAAWiC,EAAIE,QAAUF,EAAIF,UAC7B3K,EAAO,UAAG8K,EAAWrC,OAAM,YAAIqC,EAAWpC,WAEhD,EAAAsC,OAAOC,KAAK,uBAAwB,CAClCjL,KAAI,EACJ2I,WAAYmC,EAAWnC,WACvBC,SAAQ,EACRP,cAAeyC,EAAWzC,gBAG5B,EAAA6C,QAAQC,WAAW,mCAAoCvC,EAAU,CAAE5I,KAAI,EAAE2I,WAAYmC,EAAWnC,YAClG,EACF,EAxBA,GAAa,EAAAQ,O,4GChBb,0BAA+B9J,EAAkB+L,QAAA,IAAAA,OAAA,GAK/C,IAAMjL,EAAS,IAAIkL,gBACfhM,GACFc,EAAOoJ,OAAO,WAAYlK,GAExB+L,GACFjL,EAAOoJ,OAAO,eAAgB+B,OAAOC,SAASC,SAAWF,OAAOC,SAASE,QAG3E,IAAMC,EAAYjK,mBAAqBpC,GAAW+L,EAA0B,mBAAYjL,EAAO4F,YAAe,YAC9GuF,OAAOC,SAASI,KAAO,+BAAwBD,EACjD,C,mCClBA,SAASE,EAAcC,GACrB,IAAMC,EAAc,CAAC,EAQrB,OAPAvM,OAAOwM,KAAKF,GAAQ9J,SAAQ,SAACD,GACA,iBAAhB+J,EAAO/J,GAChBgK,EAAOhK,GAAO,SAEdgK,EAAOhK,GAAO8J,EAAcC,EAAO/J,GAEvC,IACOgK,CACT,C,yEAEA,8BAES,KAAAE,KAA2B,SAgCpC,QA9BE,YAAAtJ,KAAA,SAAKuJ,EAAUC,EAAgB,G,IAAE,IAAAvJ,mBAAW,IAAG,UAAO,EACzB,iBAAhBA,EACT/C,KAAKuM,cAAgBxJ,EACW,iBAAhBA,IAChB/C,KAAKuM,cAAgBxJ,EAAY,GAErC,EAEA,YAAAyJ,KAAA,SAAKxG,EAAkByG,EAAmBC,GACxC,IAAMC,EAAK,SAACC,GAEV,OADAF,EAAS,KAAME,GACR,IACT,EAEA,IACE,GAAI5G,IAAahG,KAAKuM,cAEpBI,EADgB,OAAQ,YAAcF,EAAS,gBAE1C,GAAiB,UAAbzG,EAAsB,CAE/B2G,EAAGX,EADa,OAAQ,YAAcS,EAAS,W,KAE1C,CAELE,EADgB,OAAQ,YAAqB3G,EAAQ,YAAIyG,EAAS,a,EAGpE,MAAOjN,GACPkN,EAASlN,E,CAGb,EACF,EAlCA,GAoCa,EAAAqD,eAAiB,IAAIgK,C,kHClDlC,aAMA,aAME,aALO,KAAAT,KAA2B,mBAMhCpM,KAAK8M,eAAiB,IAAI,EAAAC,oBAAe1D,EAAW,QACtD,CAoBF,OAlBS,YAAAvG,KAAP,SAAYuJ,EAAeW,EAAsBC,GAC/CjN,KAAKqM,SAAWA,EAChBrM,KAAKiN,eAAiBA,CACxB,EAEO,YAAAC,OAAP,WACE,IAAMC,EAAMnN,KAAK8M,eAAeM,UAAU,YACpCC,EAAarN,KAAKqM,SAASiB,cAAcC,mBAAmBJ,GAClE,OAAIE,GAAcrN,KAAKqM,SAASiB,cAAcE,gBAAgBH,GACrDA,EAGFrN,KAAKiN,gBAAkBjN,KAAKiN,eAAelK,aAAe/C,KAAKiN,eAAelK,YAAY,EACnG,EAEO,YAAA0K,kBAAP,SAAyBN,GACvBnN,KAAK8M,eAAeY,WAAW,WAAYP,EAC7C,EACF,EA5BA,GAAa,EAAA3K,sB,mHCNb,aACA,SACA,QAEA,iCAAsCP,EAAYuB,EAAiB2J,GAEjE,GAAqB,iBAAVlL,EAET,OAAI,IAAA0L,gBAAenK,IACV,IAAAoK,uBAAsB3L,EAAOuB,EAAQ2J,GAEvClL,EAGT,GAAIA,aAAiBuE,OAAQ,IAAAqH,cAAarK,GACxC,OAAO,IAAAsK,qBAAoB7L,EAAOuB,EAAQ2J,GAI5C,GAAqB,iBAAVlL,EAAoB,CAC7B,IAAM8L,GAAa,IAAAC,SAAO,IAAAzD,UAAStI,IAGnC,IAAI,IAAAgM,SAAQF,KAAe,IAAAF,cAAarK,GACtC,OAAO,IAAAsK,qBAAoBC,EAAYvK,EAAQ2J,E,CAInD,OAAOlL,CACT,C,kGC7BA,aAEA,0BAiCA,QA1BgB,EAAAiH,KAAd,WACE,OAAgG,OAArFwC,OAAewC,WAAa,CAAC,GAAGC,YAAc,IAAIC,MAAM,YAAc,IAAI1N,MACvF,EAKc,EAAA2N,mBAAd,WACE,IAAMC,EAAa5C,OAAe4C,UAClC,SACE3C,SAAS4C,YACoD,IAA5D5C,SAAS4C,SAASC,QAAQvF,EAAMwF,yBAC9BH,GAAaA,EAAUI,iBAAmBzF,EAAM0F,kBAMvD,EAKc,EAAAvF,uBAAd,WACE,QAAQ,IAAI5C,MAAOoI,UAAuB,KAAX,IAAAC,WAAgB1I,SAAS,GAC1D,EA/Be,EAAAwI,iBAA2B,UAC3B,EAAAF,uBAAiC,UAAGxF,EAAM0F,iBAAgB,KA+B3E,C,CAjCA,GAAa,EAAA1F,O,qZCFb,OACA,WACA,UACA,SACA,SACA,SACA,QACA,SACA,QACA,QACA,SACA,SAEa,EAAA6F,QAAU,CACrBC,KAAM,OACNC,IAAK,MACLC,KAAM,OACNC,MAAO,QACPC,IAAK,MACLC,OAAQ,UAYV,iBAGE,WAAYC,GACVrP,KAAKsP,SAAWD,GAAW,EAC7B,CAoLF,OAlLS,YAAAE,KAAP,SAAeC,EAAapJ,GAC1B,YAD0B,IAAAA,MAAA,IACnBpG,KAAKyP,MAAS,EAAAX,QAAQC,KAAMS,EAAKpJ,EAC1C,EAEO,YAAAsJ,IAAP,SAAcF,EAAapJ,GACzB,YADyB,IAAAA,MAAA,IAClBpG,KAAKyP,MAAS,EAAAX,QAAQE,IAAKQ,EAAKpJ,EACzC,EAEO,YAAAuJ,KAAP,SAAeH,EAAapJ,GAC1B,YAD0B,IAAAA,MAAA,IACnBpG,KAAKyP,MAAS,EAAAX,QAAQG,KAAMO,EAAKpJ,EAC1C,EAEO,YAAAwJ,IAAP,SAAcJ,EAAapJ,GACzB,YADyB,IAAAA,MAAA,IAClBpG,KAAKyP,MAAS,EAAAX,QAAQK,IAAKK,EAAKpJ,EACzC,EAEO,YAAAyJ,MAAP,SAAgBL,EAAapJ,GAC3B,YAD2B,IAAAA,MAAA,IACpBpG,KAAKyP,MAAS,EAAAX,QAAQI,MAAOM,EAAKpJ,EAC3C,EAEO,YAAA0J,OAAP,SAAiBN,EAAapJ,GAC5B,YAD4B,IAAAA,MAAA,IACrBpG,KAAKyP,MAAS,EAAAX,QAAQM,OAAQI,EAAKpJ,EAC5C,EAKO,YAAA2J,KAAP,SAAelH,EAAgB2G,EAAapJ,GAC1C,OAAOpG,KAAKyP,MAAS5G,EAAQ2G,EAAKpJ,EACpC,EAKQ,YAAAqJ,MAAR,SAAiB5G,EAAgB2G,EAAapJ,GAC5C,IAAMqC,EAAgBC,EAAKC,KACrBC,EAAkD,CACtDC,OAAM,EACNC,UAAW0G,EACXzG,WAAY,UACZC,SAAU,EACVP,cAAa,GAITgB,EAAU,IAAIC,QAEpBD,EAAQE,OAAO,qBAAsBlB,GAErCgB,EAAQE,OAAO,0BAA2B,WAG1C,IAAA3H,QAAOoE,EAAQqD,SAAW,CAAC,GAAG,SAACxH,EAAOC,GACpCuH,EAAQE,OAAOzH,EAAMD,EACvB,IAGA,IAAI1B,EAAS6F,EAAQ7F,QAAU,CAAC,EAC1ByP,EAAY,IAAIC,EAAIT,EAAK,KAC3BlP,EAAO0P,EAAUpE,SACfsE,EAAWF,EAAUE,SACrBC,EAAOH,EAAUG,KACjBC,EAAe,CAAEjH,QAAS,EAAAF,MAAMG,0BAGtC7I,EAASZ,OAAO0Q,OAAO,CAAC,EAAG9P,EAAQ,EAAA0I,MAAMC,OAASkH,EAAe,CAAC,GAGlE9P,EAAO,EAAAgC,kBAAkBjC,MAA0B,IAApB6P,EAASxP,QAAiBJ,EAAKW,WAAW,KAAoBX,EAAb,WAAIA,GAAeC,GAKnGiP,EAAMU,EAAW,UAAGA,EAAQ,aAAKC,GAAI,OAAG7P,GAAS,UAAGN,KAAKsP,UAAQ,OAAGhP,GAIpE,IAAMgQ,EAA8B,CAClCzH,OAFFA,GAAS,IAAA0H,WAAU1H,GAGjBY,QAASA,EACTI,YAAa,eAIf,GAAIhB,IAAW,EAAAiG,QAAQG,MAAQpG,IAAW,EAAAiG,QAAQK,KAAOtG,IAAW,EAAAiG,QAAQI,OAASrG,IAAW,EAAAiG,QAAQM,OACtG,GAAKhJ,EAAQoK,OAKXF,EAAqB,KAAIlK,EAAQ7G,SALd,CACnBkK,EAAQE,OAAO,eAAgB,oBAC/B,IAAM8G,EAAc5H,IAAW,EAAAiG,QAAQM,YAAS/F,EAAY,CAAC,EAC7DiH,EAAqB,KAAII,KAAKC,UAAUvK,EAAQ7G,MAAQkR,E,CAMpD,IAAArG,EAAsBhE,EAAO,kBAC/BwK,EAAK5Q,KAEP6Q,EAAkBC,QAAQC,UA4B9B,OA1BK3K,EAAQ4K,iBACXH,EAAkBA,EACf/G,MAAK,WACJ,OAAO,EAAAgB,eAAeX,SAAS,CAAEC,kBAAiB,GACpD,IACCN,MAAK,SAACxB,GACAmB,EAAQwH,IAAI,kBACfxH,EAAQE,OAAO,gBAAiB,UAAYrB,EAAM4I,SAEtD,IACCtG,OAAM,SAACpL,GACN,GAAqB,MAAjBA,EAAMS,OAWV,MAAMT,GAJJ,IAAA2R,gBAAe,kDAAkD,EAKrE,KAGGN,EAAgB/G,MAAK,WAC1B,OAAO8G,EAAGQ,OAAU5B,EAAKc,EAAgBlK,EAASwC,EACpD,GACF,EAKQ,YAAAwI,OAAR,SACE5B,EACAc,EACAlK,EACAwC,GAGA,IAAMU,EAAQ,EAAAC,MAAMC,WAEpB,OAAOI,MAAM4F,EAAKc,GAAgBxG,MAChC,SAACC,GAKC,OAHA,EAAAR,MAAMS,eAAeV,EAAO,EAAF,KAAOV,GAAmB,CAAEG,WAAYgB,EAAS9J,OAAS,MAGhF8J,EAASE,GAEa,MAApBF,EAAS9J,OACJ6Q,QAAQC,UAEVD,QAAQC,QAAQhH,EAAS3D,EAAQiL,cAAgB,EAAAC,eAAeZ,SAGhE3G,EAASwH,OAAOzH,MAAK,SAACvK,GAE3B,GAAIA,EAAKmB,OAAS,EAChB,IACEnB,EAAOmR,KAAKrQ,MAAMd,E,CAClB,MAAOiS,G,CAIX,MAAM,IAAI,EAAA3R,WAAWkK,EAAUxK,EACjC,GAEJ,IACA,SAACC,GAKC,MAHA,EAAA+J,MAAMS,eAAeV,EAAO,EAAF,KAAOV,GAAmB,CAAEG,WAAY,WAG5D,IAAI,EAAAlJ,WAAW,CAAC,EAAG,CAAEL,MAAO,CAAEC,QAASD,EAAMC,UACrD,GAEJ,EACF,EAzLA,GAAa,EAAAgS,aA2LA,EAAAC,WAAa,IAAID,EAAW,EAAAxI,MAAMoF,qBAAuB,EAAAsD,OAAOC,0BAA4B,EAAAD,OAAOE,oBACnG,EAAAC,4BAA8B,IAAIL,EAAW,EAAAE,OAAOI,2BACpD,EAAAC,aAAe,IAAIP,C","file":"890160ac7742d70aa9c7.js","sourcesContent":["import \"whatwg-fetch\";\n\nfunction getErrorMessage(httpResponse: any, body?: any): string {\n  if (body && body.error && body.error.message) {\n    return body.error.message;\n  } else if (body && body.message) {\n    return body.message;\n  } else {\n    return httpResponse.statusText || httpResponse.message;\n  }\n}\n\n/**\n * Our own Error class\n */\nexport class FetchError extends Error {\n  constructor(public httpResponse: any, public body?: any) {\n    // Bluebird is testing typeof message property. Undefined is causing the \"promise rejected with non-error\" warning.\n    // Setting this to pre-computed string to satisfy the check.\n    super(getErrorMessage(httpResponse, body));\n    // Details: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, FetchError.prototype);\n    this.stack = httpResponse.stack || (body && body.stack);\n  }\n\n  /**\n   * Returns the message associated with the Error.\n   */\n  get message(): string {\n    // Standard message computed in the contructor should be probably good enough. But this is\n    // a legacy code and it's not clear how exactly is it used.\n    return getErrorMessage(this.httpResponse, this.body);\n  }\n\n  /**\n   * Returns the error status.\n   */\n  get status(): number {\n    return this.httpResponse.status;\n  }\n\n  /**\n   * Returns the status text for the error.\n   */\n  get statusText(): string {\n    return this.httpResponse.statusText;\n  }\n\n  /**\n   * Returns the custom code for the error.\n   */\n  get code(): string | undefined {\n    if (this.body && this.body.error && this.body.error.code) {\n      return this.body.error.code;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Needs to be here so that this guy plays well with AI.\n   * AI throws error as it doesn't allow tracking custom objects as errors,\n   * the stacktrack tracked for each of our errors is garbled.\n   */\n  get toJs(): Error {\n    const error = new Error(this.message);\n    error.stack = this.stack;\n    error.name = this.name;\n    return error;\n  }\n}\n","import { forOwn, trim, startsWith, endsWith, trimStart, trimEnd } from \"lodash\";\n\ndeclare global {\n  function encodeURIComponent(uriComponent: any): string;\n}\n\n/**\n * Utils that parse urls/parameterized urls & params.\n */\nexport class ParamsParserUtils {\n  private static _paramPrefix: string = \":\";\n  private static _alternativePrefix: string = \"{\";\n  private static _alternativeSuffix: string = \"}\";\n\n  /**\n   * Parse a url and given params.\n   *\n   * Usage: There are two ways we can pass params to a url.\n   *\n   * 1. Via named parameterized Urls\n   *    For ex:\n   *    url = `/apps/:app_id/user/:user_id`; params = { app_id: \"3\", user_id: \"john_doe\" };\n   *    should translate to -- `/apps/3/user/john_doe`\n   *\n   *    Note that any keys in the `params` object that don't match the keys in the Url\n   *    will be automatically translated to query parameters.\n   *\n   *    For ex:\n   *    url = `/apps/user`; params = { app_id: \"3\", user_id: \"john_doe\" };\n   *    should translate to -- `/apps/user?app_id=3&user_id=john_doe`\n   *\n   * 2. Via query params\n   *    For ex:\n   *    url = `/crashes/view; params = { id: \"3\", start_time: \"2016-08-10T18:19:51.794Z\" };\n   *    should translate to -- `/crashes/view?id=3&start_time=2016-08-10T18:19:51.794Z`\n   *\n   * @static\n   * @param {string} path\n   * @param {{ [key: string]: string }} params\n   * @returns {string}\n   */\n  public static parse(path: string, params: { [key: string]: any }, retainUnusedParamsAsQuery = true): string {\n    path = trim(path);\n    if (path.length === 0) {\n      return \"\";\n    }\n\n    const pathChunks = path.split(\"/\");\n\n    // Params object is later mutated with \"delete\". Copy it here to avoid any unexpected behavior for the caller.\n    params = { ...params };\n\n    // Pull out params matching the keys in the url path\n    const pathChunksWithParams = pathChunks.map((chunk: string, index: number) => {\n      if (!chunk || chunk.length === 0) {\n        return chunk;\n      }\n\n      chunk = trim(chunk);\n\n      if (\n        startsWith(chunk, this._paramPrefix) ||\n        (startsWith(chunk, this._alternativePrefix) && endsWith(chunk, this._alternativeSuffix))\n      ) {\n        let paramKey;\n        if (startsWith(chunk, this._paramPrefix)) {\n          paramKey = chunk.substr(this._paramPrefix.length);\n        } else {\n          paramKey = trimStart(chunk, this._alternativePrefix);\n          paramKey = trimEnd(paramKey, this._alternativeSuffix);\n        }\n\n        const matchingParamValue = params[paramKey];\n        const isDot = matchingParamValue !== \".\" && matchingParamValue !== \"..\";\n\n        if (typeof matchingParamValue !== \"undefined\" && isDot) {\n          // Delete the param from the params\n          delete params[paramKey];\n          // Chunks with string arrays will be replaced with {value1}/{value2}/.../{valueN}\n          const matchingParamValues = Array.isArray(matchingParamValue) ? matchingParamValue : [matchingParamValue];\n          // Encode the param\n          return matchingParamValues.map(encodeURIComponent).join(\"/\");\n        }\n      }\n\n      return chunk;\n    });\n\n    // All unmatched params are query params\n    const queryParams: string[] = [];\n    if (retainUnusedParamsAsQuery) {\n      forOwn(params || {}, (value, key) => {\n        const values = Array.isArray(value) ? value : [value];\n        values.forEach((v) => {\n          queryParams.push(`${key}=${encodeURIComponent(v)}`);\n        });\n      });\n    }\n\n    // Build the path\n    path = pathChunksWithParams.join(\"/\");\n    path = queryParams.length > 0 ? `${path}?${queryParams.join(\"&\")}` : path;\n\n    return path;\n  }\n}\n","export * from \"./http-client\";\n","/**\n * Originally from:\n * https://github.com/i18next/react-i18next/blob/a3ca87c32b6fb1f6a6dd5343396eef3c3410a1db/example/app/i18n.js\n * See License in this folder.\n */\n\nimport * as i18next from \"i18next\";\nimport { webpackBackend } from \"./webpack-backend\";\nimport { LocalStorageDetector } from \"./local-storage-language-detector\";\nimport { FormatNumbersAndDates } from \"./i18next-formatter\";\n\nconst detector = new LocalStorageDetector();\n\n// :( I have no idea what the deal is, but esModuleInterop will fix it\nlet i18nTestHackSadFace: typeof import(\"i18next\").default = i18next.default;\nif (process.env.NODE_ENV === \"test\") {\n  i18nTestHackSadFace = require(\"i18next\");\n}\n\ni18nTestHackSadFace\n  .use(webpackBackend)\n  .use(detector)\n  .init({\n    fallbackLng: \"en-US\",\n\n    // have a common namespace used around the full app\n    ns: [\"common\"],\n    defaultNS: \"common\",\n\n    // Don't try to load fallbacks codes for languages (i.e. don't try to load en for en-US)\n    load: \"currentOnly\",\n\n    // Set to `true` to enable logging\n    debug: false,\n\n    // Globally configure wait for react-i18next\n    react: {\n      useSuspense: true,\n    },\n\n    interpolation: {\n      escapeValue: false, // not needed for react!!,\n      format: FormatNumbersAndDates,\n    },\n  });\n\nexport default i18nTestHackSadFace;\nexport const t: i18next.TFunction = i18nTestHackSadFace.t.bind(i18nTestHackSadFace);\n","/**\n * Add some enum definitions to ensure correct values are used for\n * date format options\n */\nenum NumericOptions {\n  Numeric = \"numeric\",\n  TwoDigit = \"2-digit\",\n}\n\nenum StringOptions {\n  Narrow = \"narrow\",\n  Short = \"short\",\n  Long = \"long\",\n}\n\nenum MonthOptions {\n  Numeric = \"numeric\",\n  TwoDigit = \"2-digit\",\n  Narrow = \"narrow\",\n  Short = \"short\",\n  Long = \"long\",\n}\n\n// This is currently unused:\nenum TimeZoneOptions {\n  Short = \"short\",\n  Long = \"long\",\n}\n\n/**\n * Formats are as follows (all examples en-US):\n *\n * shortFullDate - Dec 6, 2017\n *\n * shortFullDateTime - Dec 6, 2017, 2:14:37 PM\n *\n * shortFullDateTimeNoSeconds - Dec 6, 2017, 2:14 PM\n *\n * shortFullDateTimeNoCurrentYear - Dec 6, 2:14 PM\n *\n * shortMonthAndDate - Dec 06\n *\n * shortMonthAndShortDate - Dec 6\n *\n * shortTime - 2:14 PM\n *\n * shortMonthAndDateAndTime - Dec 6, 2:14 PM\n *\n * full24HourTime - 14:14:37\n *\n * longFullDateTime - December 6, 2017 2:14:37 PM\n *\n * longFullDateTimeWithSecondsAndWeekday - Wednesday December 6, 2017 2:14:37 PM\n *\n * longFullMonthYear - December 2019\n *\n * longMonthAndDate - December 9\n *\n * longMonthAndDateWithTimezone - December 9 (?)\n *\n */\nexport type DateFormats =\n  | \"shortFullDate\"\n  | \"shortFullDateNoCurrentYear\"\n  | \"shortFullDateTime\"\n  | \"shortFullDateTimeNoSeconds\"\n  | \"shortFullDateTimeNoCurrentYear\"\n  | \"shortMonthAndDate\"\n  | \"shortMonthAndShortDate\"\n  | \"shortTime\"\n  | \"shortMonthAndDateAndTime\"\n  | \"full24HourTime\"\n  | \"longFullDateTime\"\n  | \"longFullDateTimeWithSecondsAndWeekday\"\n  | \"longFullMonthYear\"\n  | \"longMonthAndDate\"\n  | \"longMonthAndDateWithTimezone\";\n\nconst DateFormat: { [F in DateFormats]: Intl.DateTimeFormatOptions } = {\n  shortFullDate: {\n    month: MonthOptions.Short,\n    year: NumericOptions.Numeric,\n    day: NumericOptions.Numeric,\n  },\n  shortFullDateNoCurrentYear: {\n    month: MonthOptions.Short,\n    year: NumericOptions.Numeric,\n    day: NumericOptions.Numeric,\n  },\n  shortFullDateTime: {\n    month: MonthOptions.Short,\n    year: NumericOptions.Numeric,\n    day: NumericOptions.Numeric,\n    hour: NumericOptions.Numeric,\n    minute: NumericOptions.Numeric,\n    second: NumericOptions.Numeric,\n  },\n  shortFullDateTimeNoSeconds: {\n    month: MonthOptions.Short,\n    year: NumericOptions.Numeric,\n    day: NumericOptions.Numeric,\n    hour: NumericOptions.Numeric,\n    minute: NumericOptions.Numeric,\n  },\n  shortFullDateTimeNoCurrentYear: {\n    month: MonthOptions.Short,\n    year: NumericOptions.Numeric,\n    day: NumericOptions.Numeric,\n    hour: NumericOptions.Numeric,\n    minute: NumericOptions.Numeric,\n  },\n  shortMonthAndDate: {\n    month: MonthOptions.Short,\n    day: NumericOptions.TwoDigit,\n  },\n  shortMonthAndShortDate: {\n    month: MonthOptions.Short,\n    day: NumericOptions.Numeric,\n  },\n  shortTime: {\n    hour: NumericOptions.Numeric,\n    minute: NumericOptions.Numeric,\n  },\n  shortMonthAndDateAndTime: {\n    month: MonthOptions.Short,\n    day: NumericOptions.Numeric,\n    hour: NumericOptions.Numeric,\n    minute: NumericOptions.Numeric,\n  },\n  full24HourTime: {\n    hour: NumericOptions.TwoDigit,\n    minute: NumericOptions.TwoDigit,\n    second: NumericOptions.TwoDigit,\n    hour12: false,\n  },\n  longFullDateTime: {\n    month: MonthOptions.Long,\n    year: NumericOptions.Numeric,\n    day: NumericOptions.Numeric,\n    hour: NumericOptions.Numeric,\n    minute: NumericOptions.Numeric,\n    second: NumericOptions.Numeric,\n  },\n  longFullDateTimeWithSecondsAndWeekday: {\n    weekday: StringOptions.Long,\n    month: MonthOptions.Long,\n    day: NumericOptions.Numeric,\n    year: NumericOptions.Numeric,\n    hour: NumericOptions.Numeric,\n    minute: NumericOptions.Numeric,\n    second: NumericOptions.Numeric,\n  },\n  longFullMonthYear: {\n    month: MonthOptions.Long,\n    year: NumericOptions.Numeric,\n  },\n  longMonthAndDate: {\n    month: MonthOptions.Long,\n    day: NumericOptions.Numeric,\n  },\n  longMonthAndDateWithTimezone: {\n    month: MonthOptions.Long,\n    day: NumericOptions.Numeric,\n    timeZoneName: TimeZoneOptions.Short,\n  },\n};\n\n/**\n * Checks whether the supplied date format name is supported by the formatter function.\n *\n * @param format The name of the date format to check.\n */\nexport function isDateFormat(format?: string): format is DateFormats {\n  if (!format) {\n    return false;\n  }\n\n  const parts = format.split(\":\");\n  return DateFormat.hasOwnProperty(parts[0]);\n}\n\nfunction getFormatOptions(format: DateFormats | string): Intl.DateTimeFormatOptions {\n  const parts = format.split(\":\");\n  const options: Intl.DateTimeFormatOptions = DateFormat[parts[0]];\n\n  if (parts.length === 2 && parts[1] === \"utc\") {\n    return { ...options, timeZone: \"UTC\" };\n  }\n\n  return { ...options };\n}\n/**\n * Formats a date value with the named format options, according to the localization rules of the language.\n *\n * @param date The date value to format.\n * @param format The named date format.\n * @param language The language code whose localization rules should be used to format the date value.\n * @returns The formatted localized date value.\n */\nexport function formatLocalizedDate(date: Date, format: DateFormats | string, language?: string): string {\n  if (!global.Intl) {\n    // We can't localize the date for users whose browsers don't support Intl, so at least return something.\n    return date.toString();\n  }\n\n  // More information about formatting in i18next can be found here:\n  // https://www.i18next.com/formatting.html\n  let options = getFormatOptions(format);\n  if (format === \"shortFullDateTimeNoCurrentYear\" || format === \"shortFullDateNoCurrentYear\") {\n    const isCurrentYear = date.getFullYear() === new Date().getFullYear();\n    if (isCurrentYear) {\n      delete options.year;\n    }\n  }\n  const formatter = new Intl.DateTimeFormat(language, options);\n\n  return formatter.format(date);\n}\n","export * from \"./date-formatter\";\nexport * from \"./i18n\";\nexport * from \"./i18next-formatter\";\nexport * from \"./local-storage-language-detector\";\nexport * from \"./number-formatter\";\nexport * from \"./utils\";\nexport * from \"./webpack-backend\";\n","import i18next from \"i18next\";\n\n/**\n * Gets the currently set language in the portal\n */\nexport function getCurrentLanguage(): string {\n  const untyped = i18next as any;\n  return untyped && untyped.default && untyped.default.languages && untyped.default.languages.length > 0\n    ? untyped.default.languages[0]\n    : \"en-US\";\n}\n","enum NumberStyleOptions {\n  Decimal = \"decimal\",\n  Currency = \"currency\",\n  Percent = \"percent\",\n}\n\nenum CurrencyDisplayOptions {\n  Symbol = \"symbol\",\n  Code = \"code\",\n  Name = \"name\",\n}\n\n/**\n * The number formats supported by localization.\n */\nexport type NumberFormats = \"standard\" | \"grouped\" | \"decimal\" | \"currency\" | \"percent\" | \"percentFixed\";\n\nconst NumberFormat: { [F in NumberFormats]: Intl.NumberFormatOptions } = {\n  standard: {\n    style: NumberStyleOptions.Decimal,\n    useGrouping: false,\n    minimumFractionDigits: 0,\n  },\n  grouped: {\n    style: NumberStyleOptions.Decimal,\n    useGrouping: true,\n    minimumFractionDigits: 0,\n  },\n  decimal: {\n    style: NumberStyleOptions.Decimal,\n    useGrouping: true,\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n  },\n  currency: {\n    style: NumberStyleOptions.Currency,\n    // @ts-ignore\n    currencyDisplay: CurrencyDisplayOptions.Symbol,\n  },\n  percent: {\n    style: NumberStyleOptions.Percent,\n  },\n  percentFixed: {\n    style: NumberStyleOptions.Percent,\n  },\n};\n\n/**\n * Checks whether the supplied number format is supported by the formatter function.\n *\n * @param format The name of the number format to check.\n */\nexport function isNumberFormat(format?: string): format is NumberFormats {\n  if (!format) {\n    return false;\n  }\n\n  const parts = format.split(\":\");\n  return NumberFormat.hasOwnProperty(parts[0]);\n}\n\nexport function getFormatOptions(format: NumberFormats | string): Intl.NumberFormatOptions {\n  const parts = format.split(\":\");\n  const formatName = parts[0];\n  const options: Intl.NumberFormatOptions = NumberFormat[formatName];\n  // TODO Will eventually need to look up what currency this customer's account is charged in.\n  // For now, we just always charge in USD.\n  if (formatName === \"currency\") {\n    const currencyOpts: any = { currency: \"USD\" };\n    if (parts.length === 2 && parts[1] === \"short\") {\n      currencyOpts.minimumFractionDigits = 0;\n      currencyOpts.maximumFractionDigits = 0;\n    }\n    return { ...options, ...currencyOpts };\n  } else if ((formatName === \"decimal\" || formatName === \"percentFixed\") && parts.length === 2) {\n    const digits = Number.parseInt(parts[1], 10);\n    return { ...options, minimumFractionDigits: digits, maximumFractionDigits: digits };\n  } else if ((formatName === \"percent\" || formatName === \"grouped\") && parts.length === 2) {\n    // Precision on these only affects the maximum digits displayed\n    const digits = Number.parseInt(parts[1], 10);\n    return { ...options, maximumFractionDigits: digits };\n  }\n\n  return { ...options };\n}\n\n/**\n * Formats a number value with the named format options, according to the localization rules of the language.\n *\n * @param number The number value to format.\n * @param format The named number format.\n * @param language The langauge code whose localization rules should be used to format the number value.\n * @returns The formatted localized number value.\n */\nexport function formatLocalizedNumber(number: number, format: NumberFormats, language?: string): string {\n  if (!global.Intl) {\n    // We can't localize numbers for users whose browsers don't support Intl, so at least return something.\n    return number.toString();\n  }\n  const options = getFormatOptions(format);\n  // TODO This will probably eventually need to look up a region setting for the user and only fall back to language if one isn't available\n  const formatter = new Intl.NumberFormat(language, options);\n\n  return formatter.format(number);\n}\n","import { IHttpOptions } from \"@lib/common-interfaces\";\n\nexport enum ProgressBarStatus {\n  Default,\n  Indeterminate,\n  Error,\n}\n\nexport enum UploadStatus {\n  UploadStarted,\n  UploadFailedPost,\n  UploadFailedBlocks,\n  UploadFailedPatch,\n  UploadFailed,\n  UploadProcessing,\n  UploadSuccessful,\n}\n\nexport interface IDragDropUploadHandlerStore {\n  uploadPercent: number;\n  file?: File;\n  errorMessage?: string;\n  uploadStatus?: UploadStatus;\n  progressBarStatus?: ProgressBarStatus;\n  validExtensions?: string[];\n\n  upload(file: any, requiredValidation?: boolean): void;\n  reset?(): void;\n  dispose?(): void;\n  setProgressBarStatus?(progressBarStatus: ProgressBarStatus): void;\n\n  initUpload?(file: any): void;\n  beginUpload?(options?: IHttpOptions): Promise<void>;\n}\n","//\n// Utility function to fetch user token from our server\n// and cache it until expiration.\n//\n\nimport \"whatwg-fetch\";\nimport { parseISO, addMinutes, isAfter } from \"date-fns\";\nimport { FetchError } from \"./fetch-error\";\nimport { Timer, RequestTelemetryProperties } from \"./timer\";\nimport { Utils } from \"./utils\";\nimport * as uuid from \"uuid\";\nimport { ParamsParserUtils } from \"./params-parser-utils\";\n\nexport interface UserToken {\n  jwtToken: string;\n  expirationTime: string;\n}\n\nlet token: Promise<UserToken> | undefined;\n\nlet authEndpoint = \"/auth/token\";\nconst tokenExpirationWindowInMinutes = 10;\n\nexport class HttpTokenUtils {\n  public static fetchToken(): Promise<UserToken> {\n    const correlationId = uuid.v4();\n    const telemetryProperties: RequestTelemetryProperties = {\n      method: \"GET\",\n      routePath: authEndpoint,\n      statusCode: \"Pending\",\n      duration: 0,\n      correlationId,\n    };\n    // Start the lap\n    authEndpoint = ParamsParserUtils.parse(authEndpoint, {\n      ...((Utils.isIe() && { nocache: Utils.randomCacheBusterValue() }) || undefined),\n    });\n    const start = Timer.startLap();\n    const headers = new Headers();\n    headers.append(\"diagnostic-context\", correlationId);\n\n    return fetch(authEndpoint, {\n      method: \"get\",\n      headers: headers,\n      credentials: \"include\",\n    }).then(\n      (response: Response) => {\n        // End the lap\n        Timer.endLapAndTrack(start, { ...telemetryProperties, statusCode: response.status + \"\" });\n\n        if (response.ok) {\n          return response.json() as Promise<UserToken>;\n        } else {\n          throw new FetchError(response);\n        }\n      },\n      (error: Error) => {\n        // End the lap\n        Timer.endLapAndTrack(start, { ...telemetryProperties, statusCode: \"Error\" });\n\n        throw new FetchError(error);\n      }\n    );\n  }\n\n  public static getToken(options: { forceRefreshToken: boolean | undefined }) {\n    const { forceRefreshToken = false } = options;\n\n    return this.getCurrentToken(forceRefreshToken)\n      .then((token: UserToken) => {\n        const expiration = parseISO(token.expirationTime);\n        const now = new Date();\n        if (isAfter(addMinutes(now, tokenExpirationWindowInMinutes), expiration)) {\n          // Expired or about to, get a new token\n          return this.getCurrentToken(true);\n        }\n        // Otherwise we're still good, return what we've got\n        return token;\n      })\n      .catch((err: FetchError) => {\n        // Wipe out cache so we retry next time\n        token = undefined;\n        // and continue with the failure\n        throw err;\n      });\n  }\n\n  private static getCurrentToken(forceRefreshToken: boolean): Promise<UserToken> {\n    if (!token || forceRefreshToken) {\n      token = this.fetchToken();\n    }\n    return token;\n  }\n}\n","import { metrics, logger } from \"../telemetry\";\n\n/**\n * Contract for a Lap used by the Timer.\n */\nexport interface Lap {\n  startInMs: number;\n  endInMs?: number;\n}\n\nexport interface RequestTelemetryProperties {\n  method: string;\n  routePath: string;\n  statusCode: string;\n  duration: number;\n  correlationId: string;\n}\n\n/*\n * Times an action which returns a Promise\n */\nexport class Timer {\n  /**\n   * Time the given action.\n   * Action should be a function returning a Promise.\n   */\n  public static startLap(): Lap {\n    return { startInMs: new Date().getTime() };\n  }\n\n  public static endLapAndTrack(lap: Lap, properties: RequestTelemetryProperties): void {\n    lap.endInMs = new Date().getTime();\n\n    const duration = lap.endInMs - lap.startInMs;\n    const name = `${properties.method} ${properties.routePath}`;\n\n    logger.info(\"outbound-request-log\", {\n      name,\n      statusCode: properties.statusCode,\n      duration,\n      correlationId: properties.correlationId,\n    });\n\n    metrics.emitMetric(\"portal-outbound-request-duration\", duration, { name, statusCode: properties.statusCode });\n  }\n}\n","/**\n * Redirects the user to the logout page, with a return URL to the sign-in page\n *\n * @param message The message to show on the login screen after logout\n */\nexport function logoutToSignIn(message?: string, returnToCurrentLocation: boolean = false) {\n  // This function had to be moved to its own module so it could be used in the `http` wrapper without\n  // causing issues with import order during the tests. We still want to share this logic as much as possible,\n  // and it's good to have it accessible from locationStore. This way, we can have it present there, and\n  // be able to use it in the `http` wrapper.\n  const params = new URLSearchParams();\n  if (message) {\n    params.append(\"errorMsg\", message);\n  }\n  if (returnToCurrentLocation) {\n    params.append(\"original_url\", window.location.pathname + window.location.search);\n  }\n  // Encode the return URL so it can be provided as a query parameter\n  const returnUrl = encodeURIComponent(!!message || returnToCurrentLocation ? `/sign-in?${params.toString()}` : \"/sign-in\");\n  window.location.href = `/logout?original_url=${returnUrl}`;\n}\n","import * as i18next from \"i18next\";\n\nfunction replaceLeaves(object: object) {\n  const result: any = {};\n  Object.keys(object).forEach((key) => {\n    if (typeof object[key] === \"string\") {\n      result[key] = \"XXXXXX\";\n    } else {\n      result[key] = replaceLeaves(object[key]);\n    }\n  });\n  return result;\n}\n\nclass WebpackI18nextBackend implements i18next.Module {\n  private defaultLocale?: string;\n  public type: i18next.ModuleType = \"backend\";\n\n  init(services, backendOptions, { fallbackLng = \"en-US\" }: i18next.InitOptions) {\n    if (typeof fallbackLng === \"string\") {\n      this.defaultLocale = fallbackLng;\n    } else if (typeof fallbackLng === \"object\") {\n      this.defaultLocale = fallbackLng[0];\n    }\n  }\n\n  read(language: string, namespace: string, callback: (err: Error | null, results?: object) => void) {\n    const cb = (content: object) => {\n      callback(null, content);\n      return null;\n    };\n\n    try {\n      if (language === this.defaultLocale) {\n        const content = require(`../../i18n/${namespace}.json`);\n        cb(content);\n      } else if (language === \"debug\") {\n        const content = require(`../../i18n/${namespace}.json`);\n        cb(replaceLeaves(content));\n      } else {\n        const content = require(`../../../handback/${language}/${namespace}.resjson`)\n        cb(content);\n      }\n    } catch (error: any) {\n      callback(error);\n    }\n\n  }\n}\n\nexport const webpackBackend = new WebpackI18nextBackend();\n","import { StorageManager } from \"../utils/storage-manager\";\nimport * as i18next from \"i18next\";\n\n// This is a plugin for i18next, specifically a language detector. Information about the\n// methods and members that must exist can be found here:\n// https://www.i18next.com/misc/creating-own-plugins.html#languagedetector\nexport class LocalStorageDetector implements i18next.Module {\n  public type: i18next.ModuleType = \"languageDetector\";\n  private storageManager: StorageManager;\n  private services: any;\n  private i18nextOptions?: i18next.InitOptions;\n\n  constructor() {\n    this.storageManager = new StorageManager(undefined, \"shell\");\n  }\n\n  public init(services: any, detectorOptions: any, i18nextOptions: i18next.InitOptions) {\n    this.services = services;\n    this.i18nextOptions = i18nextOptions;\n  }\n\n  public detect() {\n    const lng = this.storageManager.getObject(\"language\");\n    const cleanedLng = this.services.languageUtils.formatLanguageCode(lng);\n    if (cleanedLng && this.services.languageUtils.isSupportedCode(cleanedLng)) {\n      return cleanedLng;\n    }\n\n    return this.i18nextOptions && this.i18nextOptions.fallbackLng && this.i18nextOptions.fallbackLng[0];\n  }\n\n  public cacheUserLanguage(lng) {\n    this.storageManager.saveObject(\"language\", lng);\n  }\n}\n","import { formatLocalizedDate, isDateFormat } from \"./date-formatter\";\nimport { formatLocalizedNumber, isNumberFormat } from \"./number-formatter\";\nimport { toDate, parseISO, isValid } from \"date-fns\";\n\nexport function FormatNumbersAndDates(value: any, format?: string, lng?: string): any {\n  // Do numbers first, so we don't accidentally convert a number to a date\n  if (typeof value === \"number\") {\n    // TODO: Institute number formatting\n    if (isNumberFormat(format)) {\n      return formatLocalizedNumber(value, format, lng);\n    }\n    return value;\n  }\n\n  if (value instanceof Date && isDateFormat(format)) {\n    return formatLocalizedDate(value, format, lng);\n  }\n\n  // Check to see if the value is a string representation of a date\n  if (typeof value === \"string\") {\n    const parsedDate = toDate(parseISO(value));\n\n    // Only accept our named date formats\n    if (isValid(parsedDate) && isDateFormat(format)) {\n      return formatLocalizedDate(parsedDate, format, lng);\n    }\n  }\n\n  return value;\n}\n","import { random } from \"../utils/random\";\n\nexport class Utils {\n  private static InstallSubdomain: string = \"install\";\n  private static InstallSubdomainPrefix: string = `${Utils.InstallSubdomain}.`;\n\n  /**\n   * Checks if the browser is IE.\n   */\n  public static isIe(): boolean {\n    return ((((window as any).navigator || {}).appVersion || \"\").match(/Trident/) || []).length !== 0;\n  }\n\n  /**\n   * Checks if the domain is the install subdomain\n   */\n  public static isInstallSubdomain(): boolean {\n    const initProps = (window as any).initProps;\n    if (\n      location.hostname &&\n      (location.hostname.indexOf(Utils.InstallSubdomainPrefix) === 0 ||\n        (initProps && initProps.forceSubdomain === Utils.InstallSubdomain))\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get a random cache buster value.\n   */\n  public static randomCacheBusterValue(): string {\n    return (new Date().valueOf() + random() * 100).toString(36);\n  }\n}\n","import \"whatwg-fetch\";\nimport { forOwn, upperCase } from \"lodash\";\nimport * as Url from \"url-parse\";\nimport { HttpTokenUtils, UserToken } from \"./get-token\";\nimport { Timer, RequestTelemetryProperties } from \"./timer\";\nimport { ParamsParserUtils } from \"./params-parser-utils\";\nimport { IHttpOptions, RESPONSE_TYPES } from \"@lib/common-interfaces\";\nimport { FetchError } from \"./fetch-error\";\nimport { Utils } from \"./utils\";\nimport { config } from \"../utils/config\";\nimport { logoutToSignIn } from \"./redirect-to-login-utils\";\nimport uuid = require(\"uuid\");\n\nexport const METHODS = {\n  HEAD: \"HEAD\",\n  GET: \"GET\",\n  POST: \"POST\",\n  PATCH: \"PATCH\",\n  PUT: \"PUT\",\n  DELETE: \"DELETE\",\n};\n\n/**\n * Http library\n *\n * Our custom wrapper for Http. This library uses the `fetch` library underneath its covers.\n * This library encapsulates the action of fetching the authentication token which is required to\n * talk to our backend API's.\n *\n * This library accepts parameterized urls and can parse them with corresponding params to create urls.\n */\nexport class HttpClient {\n  private _rootUrl: string;\n\n  constructor(rootUrl?: string) {\n    this._rootUrl = rootUrl || \"\";\n  }\n\n  public head<T>(url: string, options: IHttpOptions = {}): Promise<T> {\n    return this._call<T>(METHODS.HEAD, url, options);\n  }\n\n  public get<T>(url: string, options: IHttpOptions = {}): Promise<T> {\n    return this._call<T>(METHODS.GET, url, options);\n  }\n\n  public post<T>(url: string, options: IHttpOptions = {}): Promise<T> {\n    return this._call<T>(METHODS.POST, url, options);\n  }\n\n  public put<T>(url: string, options: IHttpOptions = {}): Promise<T> {\n    return this._call<T>(METHODS.PUT, url, options);\n  }\n\n  public patch<T>(url: string, options: IHttpOptions = {}): Promise<T> {\n    return this._call<T>(METHODS.PATCH, url, options);\n  }\n\n  public delete<T>(url: string, options: IHttpOptions = {}): Promise<T> {\n    return this._call<T>(METHODS.DELETE, url, options);\n  }\n\n  /**\n   * Calls the fetch library using the method provided.\n   */\n  public call<T>(method: string, url: string, options: IHttpOptions): Promise<T> {\n    return this._call<T>(method, url, options);\n  }\n\n  /**\n   * Core function which makes the Http call using the fetch library.\n   */\n  private _call<T>(method: string, url: string, options: IHttpOptions): Promise<T> {\n    const correlationId = uuid.v4();\n    const telemetryProperties: RequestTelemetryProperties = {\n      method,\n      routePath: url,\n      statusCode: \"Pending\",\n      duration: 0,\n      correlationId,\n    };\n\n    // Add headers\n    const headers = new Headers();\n    // Add diagnostc context id\n    headers.append(\"diagnostic-context\", correlationId);\n    // Add source header to track in API gateway\n    headers.append(\"internal-request-source\", \"portal\");\n\n    // Append passed in headers\n    forOwn(options.headers || {}, (value, key) => {\n      headers.append(key!, value);\n    });\n\n    // Add params\n    let params = options.params || {};\n    const parsedUrl = new Url(url, \"/\"); /** Setting no base url if the url to be parsed is relative */\n    let path = parsedUrl.pathname;\n    const protocol = parsedUrl.protocol;\n    const host = parsedUrl.host;\n    const noCacheParam = { nocache: Utils.randomCacheBusterValue() };\n\n    // Add no cache param if the browser is IE.\n    params = Object.assign({}, params, Utils.isIe() ? noCacheParam : {});\n\n    // Parse the path with the params provided\n    path = ParamsParserUtils.parse(protocol.length === 0 && !path.startsWith(\"/\") ? `/${path}` : path, params);\n\n    // Build the URL\n    // If the url provided is an absolute url, use the protocol & host from that url to create the new one.\n    // If the url provided is a relative url, use the rootUrl -- which can be empty or set to a specific value.\n    url = protocol ? `${protocol}//${host}${path}` : `${this._rootUrl}${path}`;\n\n    // Prepare requestOptions for fetch\n    method = upperCase(method);\n    const requestOptions: RequestInit = {\n      method: method,\n      headers: headers,\n      credentials: \"same-origin\", // enable cookies\n    };\n\n    // Add Content-Type header & body for the right methods\n    if (method === METHODS.POST || method === METHODS.PUT || method === METHODS.PATCH || method === METHODS.DELETE) {\n      if (!options.noJson) {\n        headers.append(\"Content-Type\", \"application/json\");\n        const defaultBody = method === METHODS.DELETE ? undefined : {};\n        requestOptions[\"body\"] = JSON.stringify(options.body || defaultBody);\n      } else {\n        requestOptions[\"body\"] = options.body;\n      }\n    }\n\n    const { forceRefreshToken } = options;\n    const me = this;\n\n    let prepareForFetch = Promise.resolve();\n\n    if (!options.noBifrostToken) {\n      prepareForFetch = prepareForFetch\n        .then(() => {\n          return HttpTokenUtils.getToken({ forceRefreshToken });\n        })\n        .then((token: UserToken) => {\n          if (!headers.has(\"Authorization\")) {\n            headers.append(\"Authorization\", \"Bearer \" + token.jwtToken);\n          }\n        })\n        .catch((error: FetchError) => {\n          if (error.status === 401) {\n            // We got the \"need to re-auth\" error response from the token endpoint. We should log the user out and redirect\n            // to the sign-in page.\n            // Preferrably this would come from the error message's body itself. However, turns out you need to\n            // evaluate a promise in order to get the body data, which hasn't happened yet when the error is thrown.\n            // It would take some  refactoring of our http/fetch wrapper itself in order to make this happen, so I'm\n            // not tackling it just yet.\n            logoutToSignIn(\"Your session has expired. Please log in again.\", true);\n            return;\n          }\n          // Make sure to not swallow any other errors that may have occurred.\n          throw error;\n        });\n    }\n\n    return prepareForFetch.then(() => {\n      return me._fetch<T>(url, requestOptions, options, telemetryProperties);\n    });\n  }\n\n  /**\n   * Makes the fetch call.\n   */\n  private _fetch<T>(\n    url: string,\n    requestOptions: RequestInit,\n    options: IHttpOptions,\n    telemetryProperties: RequestTelemetryProperties\n  ): Promise<T> {\n    // Start the time lap\n    const start = Timer.startLap();\n\n    return fetch(url, requestOptions).then(\n      (response: Response): Promise<T> => {\n        // End the lap\n        Timer.endLapAndTrack(start, { ...telemetryProperties, statusCode: response.status + \"\" });\n\n        // Check if response is success and do the appropriate thing.\n        if (response.ok) {\n          // Do not parse content if status returns 204 NO CONTENT\n          if (response.status === 204) {\n            return Promise.resolve() as any;\n          }\n          return Promise.resolve(response[options.responseType || RESPONSE_TYPES.JSON]());\n        } else {\n          // Throws an explicit error using the error body.\n          return response.text().then((body) => {\n            // Assume that the error is a JSON object.\n            if (body.length > 0) {\n              try {\n                body = JSON.parse(body);\n              } catch (exception) {\n                // Ignore JSON parsing exception, use body as text.\n              }\n            }\n            throw new FetchError(response, body);\n          }) as any;\n        }\n      },\n      (error: Error) => {\n        // End the lap\n        Timer.endLapAndTrack(start, { ...telemetryProperties, statusCode: \"Error\" });\n\n        // throw the error\n        throw new FetchError({}, { error: { message: error.message } });\n      }\n    );\n  }\n}\n\nexport const apiGateway = new HttpClient(Utils.isInstallSubdomain() ? config.getApiGatewayUrlInstall() : config.getApiGatewayUrl());\nexport const accountManagementHttpClient = new HttpClient(config.getAccountManagementUrl());\nexport const portalServer = new HttpClient();\n"],"sourceRoot":""}