{"version":3,"sources":["webpack:///./node_modules/filesize/lib/filesize.min.js","webpack:///./node_modules/mobx-utils/mobx-utils.module.js"],"names":["x","M","iec","bits","bytes","jedec","w","t","e","i","o","n","b","r","a","l","s","d","u","c","f","p","B","y","arguments","length","g","v","m","h","isNaN","TypeError","unix","base","round","locale","localeOptions","separator","spacer","symbols","standard","output","fullform","fullforms","Array","exponent","Number","Math","floor","log","pow","toFixed","charAt","replace","test","toLocaleString","toString","value","symbol","join","partial","module","exports","window","NOOP","IDENTITY","_","fail$1","message","Error","invariant","cond","deprecatedMessages","deprecated","msg","indexOf","push","addHiddenProp","object","propName","Object","defineProperty","enumerable","writable","configurable","deepFields","prototype","getOwnPropertyNames","concat","getPrototypeOf","getAllMethodsAndProperties","deepFieldsIndistinct","filter","item","index","distinctDeepFields","name","PENDING","FULFILLED","REJECTED","caseImpl","handlers","this","state","pending","rejected","fulfilled","fromPromise","origPromise","oldPromise","then","isPromiseBasedObservable","Promise","promise","reason","case","oldData","undefined","deep","reject","resolve","__spreadArrays","il","k","j","jl","moveItem","target","fromIndex","toIndex","checkIndex","newItems","oldItems","values","slice","lazyObservable","fetch","initialValue","started","box","currentFnc","set","newValue","get","resetFnc","current","refresh","reset","fromResource","subscriber","unsubscriber","isActive","isDisposed","suspender","atom","reportChanged","reportObserved","dispose","isAlive","__decorate","decorators","key","desc","getOwnPropertyDescriptor","Reflect","decorate","toStream","expression","fireImmediately","_a","computedValue","subscribe","observer","unsubscribe","observe","next","Symbol","observable","StreamListener","_this","subscription","complete","error","ref","bound","fromStream","__assign","assign","hasOwnProperty","call","apply","__decorate$1","RESERVED_NAMES","ViewModel","model","localValues","map","localComputedValues","isPropertyDirty","has","forEach","derivation","bind","descriptor","additionalDescriptor","delete","size","toJS","submit","source","destination","clear","merge","resetProperty","createViewModel","whenWithTimeout","expr","action","timeout","onTimeout","onError","keepAlive","_1","_2","computed","queueProcessor","observableArray","processor","debounce","runner","items","splice","delay","chunkProcessor","maxChunkSize","_loop_1","chunkSize","min","tickers","now","interval","subscriptionHandle","sink","setInterval","Date","clearInterval","createIntervalTicker","frameBasedTicker","scheduleTick","requestAnimationFrame","__assign$1","asyncAction","arg1","arg2","name_1","descriptor_1","generator","whenAsync","fn","__assign$2","memoizationId","createTransformer","transformer","views","onCleanup","debugNameGenerator","memoWarned","identifier","objectType","String","tid","$transformId","getMemoizationId","reactiveView","sourceIdentifier","sourceObject","latestValue","computedValueOptions","prettifiedName","disposer_1","createView","buildPath","entry","res","parent","path","reverse","isRecursivelyObservable","thing","deepObserve","listener","entrySet","WeakMap","genericListener","change","type","observeRecursively","unobserveRecursively","oldValue","removed","added","idx","addedCount","processChange","entry_1","extendStatics","__extends","setPrototypeOf","__proto__","__","constructor","create","ObservableGroupMap","_super","groupBy","_b","_c","random","_d","keyToName","_keyToName","_groupBy","_ogmInfoKey","_base","_addItem","_disposeBaseObserver","_i","_removeItem","_key","_value","reaction","_getGroupArr","result","_removeFromGroupArr","itemIndex","arr","groupArrIndex","groupByValue","groupArr","newGroupByValue","_r","grouperItemInfo","newGroupArr","newGroupArrIndex","DeepMapEntry","args","closestIdx","closest","root","exists","assertNotDisposed","Map","maps","DeepMap","store","argsLength","last","__assign$3","computedFn","keepAliveOrOptions","opts","decorateMethodOrField","decoratorName","decorateFn","prop","fail","initializer","decorateMethod","decorateField","inOrderExecution","queueMicrotaskPolyfill_1","__awaiter","thisArg","_arguments","P","step","done","__generator","body","label","sent","trys","ops","verb","iterator","op","pop","runId","unfinishedIds","Set","currentlyActiveIds","taskOrderPromise_1","queueMicrotask","process","nextTick","cb","setTimeout","idle_1","actionAsyncContextStack","task","ctx","actionName","scope","actionRunInfo","nextStep","ret","err_1","actionRunInfo_1","getActionAsyncName","add","actionAsync","arg3","actionAsyncFn","nextRunId","finish","err_2","err"],"mappings":"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","file":"0ba3341566657f768b6e.js","sourcesContent":["/*\r\n 2020 Jason Mulligan <jason.mulligan@avoidwork.com>\r\n @version 6.1.0\r\n*/\r\n\"use strict\";!function(e){var x=/^(b|B)$/,M={iec:{bits:[\"b\",\"Kib\",\"Mib\",\"Gib\",\"Tib\",\"Pib\",\"Eib\",\"Zib\",\"Yib\"],bytes:[\"B\",\"KiB\",\"MiB\",\"GiB\",\"TiB\",\"PiB\",\"EiB\",\"ZiB\",\"YiB\"]},jedec:{bits:[\"b\",\"Kb\",\"Mb\",\"Gb\",\"Tb\",\"Pb\",\"Eb\",\"Zb\",\"Yb\"],bytes:[\"B\",\"KB\",\"MB\",\"GB\",\"TB\",\"PB\",\"EB\",\"ZB\",\"YB\"]}},w={iec:[\"\",\"kibi\",\"mebi\",\"gibi\",\"tebi\",\"pebi\",\"exbi\",\"zebi\",\"yobi\"],jedec:[\"\",\"kilo\",\"mega\",\"giga\",\"tera\",\"peta\",\"exa\",\"zetta\",\"yotta\"]};function t(e){var i,t,o,n,b,r,a,l,s,d,u,c,f,p,B,y=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},g=[],v=0,m=void 0,h=void 0;if(isNaN(e))throw new TypeError(\"Invalid number\");return t=!0===y.bits,u=!0===y.unix,i=y.base||2,d=void 0!==y.round?y.round:u?1:2,r=void 0!==y.locale?y.locale:\"\",a=y.localeOptions||{},c=void 0!==y.separator?y.separator:\"\",f=void 0!==y.spacer?y.spacer:u?\"\":\" \",B=y.symbols||{},p=2===i&&y.standard||\"jedec\",s=y.output||\"string\",n=!0===y.fullform,b=y.fullforms instanceof Array?y.fullforms:[],m=void 0!==y.exponent?y.exponent:-1,o=2<i?1e3:1024,(l=(h=Number(e))<0)&&(h=-h),(-1===m||isNaN(m))&&(m=Math.floor(Math.log(h)/Math.log(o)))<0&&(m=0),8<m&&(m=8),\"exponent\"===s?m:(0===h?(g[0]=0,g[1]=u?\"\":M[p][t?\"bits\":\"bytes\"][m]):(v=h/(2===i?Math.pow(2,10*m):Math.pow(1e3,m)),t&&o<=(v*=8)&&m<8&&(v/=o,m++),g[0]=Number(v.toFixed(0<m?d:0)),g[0]===o&&m<8&&void 0===y.exponent&&(g[0]=1,m++),g[1]=10===i&&1===m?t?\"kb\":\"kB\":M[p][t?\"bits\":\"bytes\"][m],u&&(g[1]=\"jedec\"===p?g[1].charAt(0):0<m?g[1].replace(/B$/,\"\"):g[1],x.test(g[1])&&(g[0]=Math.floor(g[0]),g[1]=\"\"))),l&&(g[0]=-g[0]),g[1]=B[g[1]]||g[1],!0===r?g[0]=g[0].toLocaleString():0<r.length?g[0]=g[0].toLocaleString(r,a):0<c.length&&(g[0]=g[0].toString().replace(\".\",c)),\"array\"===s?g:(n&&(g[1]=b[m]?b[m]:w[p][m]+(t?\"bit\":\"byte\")+(1===g[0]?\"\":\"s\")),\"object\"===s?{value:g[0],symbol:g[1],exponent:m}:g.join(f)))}t.partial=function(i){return function(e){return t(e,i)}},\"undefined\"!=typeof exports?module.exports=t:\"function\"==typeof define&&void 0!==define.amd?define(function(){return t}):e.filesize=t}(\"undefined\"!=typeof window?window:global);\r\n//# sourceMappingURL=filesize.min.js.map","import { action, extendObservable, $mobx, observable, _allowStateChanges, createAtom, computed, runInAction, keys, isObservableArray, isObservableMap, isComputed, isObservableObject, isComputedProp, _getAdministration, when, getAtom, isAction, autorun, _isComputingDerivation, flow, onBecomeUnobserved, observe, entries, values, transaction, reaction, ObservableMap, _startAction, _endAction } from 'mobx';\n\nvar NOOP = function () { };\r\nvar IDENTITY = function (_) { return _; };\r\nfunction fail$1(message) {\r\n    throw new Error(\"[mobx-utils] \" + message);\r\n}\r\nfunction invariant(cond, message) {\r\n    if (message === void 0) { message = \"Illegal state\"; }\r\n    if (!cond)\r\n        fail$1(message);\r\n}\r\nvar deprecatedMessages = [];\r\nfunction deprecated(msg) {\r\n    if (deprecatedMessages.indexOf(msg) !== -1)\r\n        return;\r\n    deprecatedMessages.push(msg);\r\n    console.error(\"[mobx-utils] Deprecated: \" + msg);\r\n}\r\nfunction addHiddenProp(object, propName, value) {\r\n    Object.defineProperty(object, propName, {\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true,\r\n        value: value,\r\n    });\r\n}\r\nvar deepFields = function (x) {\r\n    return (x &&\r\n        x !== Object.prototype &&\r\n        Object.getOwnPropertyNames(x).concat(deepFields(Object.getPrototypeOf(x)) || []));\r\n};\r\nvar distinctDeepFields = function (x) {\r\n    var deepFieldsIndistinct = deepFields(x);\r\n    var deepFieldsDistinct = deepFieldsIndistinct.filter(function (item, index) { return deepFieldsIndistinct.indexOf(item) === index; });\r\n    return deepFieldsDistinct;\r\n};\r\nvar getAllMethodsAndProperties = function (x) {\r\n    return distinctDeepFields(x).filter(function (name) { return name !== \"constructor\" && !~name.indexOf(\"__\"); });\r\n};\n\nvar PENDING = \"pending\";\r\nvar FULFILLED = \"fulfilled\";\r\nvar REJECTED = \"rejected\";\r\nfunction caseImpl(handlers) {\r\n    switch (this.state) {\r\n        case PENDING:\r\n            return handlers.pending && handlers.pending(this.value);\r\n        case REJECTED:\r\n            return handlers.rejected && handlers.rejected(this.value);\r\n        case FULFILLED:\r\n            return handlers.fulfilled ? handlers.fulfilled(this.value) : this.value;\r\n    }\r\n}\r\n/**\r\n * `fromPromise` takes a Promise, extends it with 2 observable properties that track\r\n * the status of the promise and returns it. The returned object has the following observable properties:\r\n *  - `value`: either the initial value, the value the Promise resolved to, or the value the Promise was rejected with. use `.state` if you need to be able to tell the difference.\r\n *  - `state`: one of `\"pending\"`, `\"fulfilled\"` or `\"rejected\"`\r\n *\r\n * And the following methods:\r\n * - `case({fulfilled, rejected, pending})`: maps over the result using the provided handlers, or returns `undefined` if a handler isn't available for the current promise state.\r\n * - `then((value: TValue) => TResult1 | PromiseLike<TResult1>, [(rejectReason: any) => any])`: chains additional handlers to the provided promise.\r\n *\r\n * The returned object implements `PromiseLike<TValue>`, so you can chain additional `Promise` handlers using `then`. You may also use it with `await` in `async` functions.\r\n *\r\n * Note that the status strings are available as constants:\r\n * `mobxUtils.PENDING`, `mobxUtils.REJECTED`, `mobxUtil.FULFILLED`\r\n *\r\n * fromPromise takes an optional second argument, a previously created `fromPromise` based observable.\r\n * This is useful to replace one promise based observable with another, without going back to an intermediate\r\n * \"pending\" promise state while fetching data. For example:\r\n *\r\n * @example\r\n * \\@observer\r\n * class SearchResults extends React.Component {\r\n *   \\@observable.ref searchResults\r\n *\r\n *   componentDidUpdate(nextProps) {\r\n *     if (nextProps.query !== this.props.query)\r\n *       this.searchResults = fromPromise(\r\n *         window.fetch(\"/search?q=\" + nextProps.query),\r\n *         // by passing, we won't render a pending state if we had a successful search query before\r\n *         // rather, we will keep showing the previous search results, until the new promise resolves (or rejects)\r\n *         this.searchResults\r\n *       )\r\n *   }\r\n *\r\n *   render() {\r\n *     return this.searchResults.case({\r\n *        pending: (staleValue) => {\r\n *          return staleValue || \"searching\" // <- value might set to previous results while the promise is still pending\r\n *        },\r\n *        fulfilled: (value) => {\r\n *          return value // the fresh results\r\n *        },\r\n *        rejected: (error) => {\r\n *          return \"Oops: \" + error\r\n *        }\r\n *     })\r\n *   }\r\n * }\r\n *\r\n * Observable promises can be created immediately in a certain state using\r\n * `fromPromise.reject(reason)` or `fromPromise.resolve(value?)`.\r\n * The main advantage of `fromPromise.resolve(value)` over `fromPromise(Promise.resolve(value))` is that the first _synchronously_ starts in the desired state.\r\n *\r\n * It is possible to directly create a promise using a resolve, reject function:\r\n * `fromPromise((resolve, reject) => setTimeout(() => resolve(true), 1000))`\r\n *\r\n * @example\r\n * const fetchResult = fromPromise(fetch(\"http://someurl\"))\r\n *\r\n * // combine with when..\r\n * when(\r\n *   () => fetchResult.state !== \"pending\",\r\n *   () => {\r\n *     console.log(\"Got \", fetchResult.value)\r\n *   }\r\n * )\r\n *\r\n * // or a mobx-react component..\r\n * const myComponent = observer(({ fetchResult }) => {\r\n *   switch(fetchResult.state) {\r\n *      case \"pending\": return <div>Loading...</div>\r\n *      case \"rejected\": return <div>Ooops... {fetchResult.value}</div>\r\n *      case \"fulfilled\": return <div>Gotcha: {fetchResult.value}</div>\r\n *   }\r\n * })\r\n *\r\n * // or using the case method instead of switch:\r\n *\r\n * const myComponent = observer(({ fetchResult }) =>\r\n *   fetchResult.case({\r\n *     pending:   () => <div>Loading...</div>,\r\n *     rejected:  error => <div>Ooops.. {error}</div>,\r\n *     fulfilled: value => <div>Gotcha: {value}</div>,\r\n *   }))\r\n *\r\n * // chain additional handler(s) to the resolve/reject:\r\n *\r\n * fetchResult.then(\r\n *   (result) =>  doSomeTransformation(result),\r\n *   (rejectReason) => console.error('fetchResult was rejected, reason: ' + rejectReason)\r\n * ).then(\r\n *   (transformedResult) => console.log('transformed fetchResult: ' + transformedResult)\r\n * )\r\n *\r\n * @param {IThenable<T>} promise The promise which will be observed\r\n * @param {IThenable<T>} oldPromise? The previously observed promise\r\n * @returns {IPromiseBasedObservable<T>}\r\n */\r\nfunction fromPromise(origPromise, oldPromise) {\r\n    invariant(arguments.length <= 2, \"fromPromise expects up to two arguments\");\r\n    invariant(typeof origPromise === \"function\" ||\r\n        (typeof origPromise === \"object\" &&\r\n            origPromise &&\r\n            typeof origPromise.then === \"function\"), \"Please pass a promise or function to fromPromise\");\r\n    if (origPromise.isPromiseBasedObservable === true)\r\n        return origPromise;\r\n    if (typeof origPromise === \"function\") {\r\n        // If it is a (reject, resolve function, wrap it)\r\n        origPromise = new Promise(origPromise);\r\n    }\r\n    var promise = origPromise;\r\n    origPromise.then(action(\"observableFromPromise-resolve\", function (value) {\r\n        promise.value = value;\r\n        promise.state = FULFILLED;\r\n    }), action(\"observableFromPromise-reject\", function (reason) {\r\n        promise.value = reason;\r\n        promise.state = REJECTED;\r\n    }));\r\n    promise.isPromiseBasedObservable = true;\r\n    promise.case = caseImpl;\r\n    var oldData = oldPromise && oldPromise.state === FULFILLED\r\n        ? oldPromise.value\r\n        : undefined;\r\n    extendObservable(promise, {\r\n        value: oldData,\r\n        state: PENDING,\r\n    }, {}, { deep: false });\r\n    return promise;\r\n}\r\n(function (fromPromise) {\r\n    fromPromise.reject = action(\"fromPromise.reject\", function (reason) {\r\n        var p = fromPromise(Promise.reject(reason));\r\n        p.state = REJECTED;\r\n        p.value = reason;\r\n        return p;\r\n    });\r\n    function resolveBase(value) {\r\n        if (value === void 0) { value = undefined; }\r\n        var p = fromPromise(Promise.resolve(value));\r\n        p.state = FULFILLED;\r\n        p.value = value;\r\n        return p;\r\n    }\r\n    fromPromise.resolve = action(\"fromPromise.resolve\", resolveBase);\r\n})(fromPromise || (fromPromise = {}));\r\n/**\r\n * Returns true if the provided value is a promise-based observable.\r\n * @param value any\r\n * @returns {boolean}\r\n */\r\nfunction isPromiseBasedObservable(value) {\r\n    return value && value.isPromiseBasedObservable === true;\r\n}\n\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n/**\r\n * Moves an item from one position to another, checking that the indexes given are within bounds.\r\n *\r\n * @example\r\n * const source = observable([1, 2, 3])\r\n * moveItem(source, 0, 1)\r\n * console.log(source.map(x => x)) // [2, 1, 3]\r\n *\r\n * @export\r\n * @param {ObservableArray<T>} target\r\n * @param {number} fromIndex\r\n * @param {number} toIndex\r\n * @returns {ObservableArray<T>}\r\n */\r\nfunction moveItem(target, fromIndex, toIndex) {\r\n    checkIndex(target, fromIndex);\r\n    checkIndex(target, toIndex);\r\n    if (fromIndex === toIndex) {\r\n        return;\r\n    }\r\n    var oldItems = target[$mobx].values;\r\n    var newItems;\r\n    if (fromIndex < toIndex) {\r\n        newItems = __spreadArrays(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [\r\n            oldItems[fromIndex]\r\n        ], oldItems.slice(toIndex + 1));\r\n    }\r\n    else {\r\n        // toIndex < fromIndex\r\n        newItems = __spreadArrays(oldItems.slice(0, toIndex), [\r\n            oldItems[fromIndex]\r\n        ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\r\n    }\r\n    target.replace(newItems);\r\n    return target;\r\n}\r\n/**\r\n * Checks whether the specified index is within bounds. Throws if not.\r\n *\r\n * @private\r\n * @param {ObservableArray<any>} target\r\n * @param {number }index\r\n */\r\nfunction checkIndex(target, index) {\r\n    if (index < 0) {\r\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\r\n    }\r\n    var length = target[$mobx].values.length;\r\n    if (index >= length) {\r\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\r\n    }\r\n}\n\n/**\r\n * `lazyObservable` creates an observable around a `fetch` method that will not be invoked\r\n * until the observable is needed the first time.\r\n * The fetch method receives a `sink` callback which can be used to replace the\r\n * current value of the lazyObservable. It is allowed to call `sink` multiple times\r\n * to keep the lazyObservable up to date with some external resource.\r\n *\r\n * Note that it is the `current()` call itself which is being tracked by MobX,\r\n * so make sure that you don't dereference to early.\r\n *\r\n * @example\r\n * const userProfile = lazyObservable(\r\n *   sink => fetch(\"/myprofile\").then(profile => sink(profile))\r\n * )\r\n *\r\n * // use the userProfile in a React component:\r\n * const Profile = observer(({ userProfile }) =>\r\n *   userProfile.current() === undefined\r\n *   ? <div>Loading user profile...</div>\r\n *   : <div>{userProfile.current().displayName}</div>\r\n * )\r\n *\r\n * // triggers refresh the userProfile\r\n * userProfile.refresh()\r\n *\r\n * @param {(sink: (newValue: T) => void) => void} fetch method that will be called the first time the value of this observable is accessed. The provided sink can be used to produce a new value, synchronously or asynchronously\r\n * @param {T} [initialValue=undefined] optional initialValue that will be returned from `current` as long as the `sink` has not been called at least once\r\n * @returns {{\r\n *     current(): T,\r\n *     refresh(): T,\r\n *     reset(): T\r\n *     pending: boolean\r\n * }}\r\n */\r\nfunction lazyObservable(fetch, initialValue) {\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    var started = false;\r\n    var value = observable.box(initialValue, { deep: false });\r\n    var pending = observable.box(false);\r\n    var currentFnc = function () {\r\n        if (!started) {\r\n            started = true;\r\n            _allowStateChanges(true, function () {\r\n                pending.set(true);\r\n            });\r\n            fetch(function (newValue) {\r\n                _allowStateChanges(true, function () {\r\n                    value.set(newValue);\r\n                    pending.set(false);\r\n                });\r\n            });\r\n        }\r\n        return value.get();\r\n    };\r\n    var resetFnc = action(\"lazyObservable-reset\", function () {\r\n        started = false;\r\n        value.set(initialValue);\r\n        return value.get();\r\n    });\r\n    return {\r\n        current: currentFnc,\r\n        refresh: function () {\r\n            if (started) {\r\n                started = false;\r\n                return currentFnc();\r\n            }\r\n            else {\r\n                return value.get();\r\n            }\r\n        },\r\n        reset: function () {\r\n            return resetFnc();\r\n        },\r\n        get pending() {\r\n            return pending.get();\r\n        },\r\n    };\r\n}\n\n/**\r\n * `fromResource` creates an observable whose current state can be inspected using `.current()`,\r\n * and which can be kept in sync with some external datasource that can be subscribed to.\r\n *\r\n * The created observable will only subscribe to the datasource if it is in use somewhere,\r\n * (un)subscribing when needed. To enable `fromResource` to do that two callbacks need to be provided,\r\n * one to subscribe, and one to unsubscribe. The subscribe callback itself will receive a `sink` callback, which can be used\r\n * to update the current state of the observable, allowing observes to react.\r\n *\r\n * Whatever is passed to `sink` will be returned by `current()`. The values passed to the sink will not be converted to\r\n * observables automatically, but feel free to do so.\r\n * It is the `current()` call itself which is being tracked,\r\n * so make sure that you don't dereference to early.\r\n *\r\n * For inspiration, an example integration with the apollo-client on [github](https://github.com/apollostack/apollo-client/issues/503#issuecomment-241101379),\r\n * or the [implementation](https://github.com/mobxjs/mobx-utils/blob/1d17cf7f7f5200937f68cc0b5e7ec7f3f71dccba/src/now.ts#L43-L57) of `mobxUtils.now`\r\n *\r\n * The following example code creates an observable that connects to a `dbUserRecord`,\r\n * which comes from an imaginary database and notifies when it has changed.\r\n *\r\n * @example\r\n * function createObservableUser(dbUserRecord) {\r\n *   let currentSubscription;\r\n *   return fromResource(\r\n *     (sink) => {\r\n *       // sink the current state\r\n *       sink(dbUserRecord.fields)\r\n *       // subscribe to the record, invoke the sink callback whenever new data arrives\r\n *       currentSubscription = dbUserRecord.onUpdated(() => {\r\n *         sink(dbUserRecord.fields)\r\n *       })\r\n *     },\r\n *     () => {\r\n *       // the user observable is not in use at the moment, unsubscribe (for now)\r\n *       dbUserRecord.unsubscribe(currentSubscription)\r\n *     }\r\n *   )\r\n * }\r\n *\r\n * // usage:\r\n * const myUserObservable = createObservableUser(myDatabaseConnector.query(\"name = 'Michel'\"))\r\n *\r\n * // use the observable in autorun\r\n * autorun(() => {\r\n *   // printed everytime the database updates its records\r\n *   console.log(myUserObservable.current().displayName)\r\n * })\r\n *\r\n * // ... or a component\r\n * const userComponent = observer(({ user }) =>\r\n *   <div>{user.current().displayName}</div>\r\n * )\r\n *\r\n * @export\r\n * @template T\r\n * @param {(sink: (newValue: T) => void) => void} subscriber\r\n * @param {IDisposer} [unsubscriber=NOOP]\r\n * @param {T} [initialValue=undefined] the data that will be returned by `get()` until the `sink` has emitted its first data\r\n * @returns {{\r\n *     current(): T;\r\n *     dispose(): void;\r\n *     isAlive(): boolean;\r\n * }}\r\n */\r\nfunction fromResource(subscriber, unsubscriber, initialValue) {\r\n    if (unsubscriber === void 0) { unsubscriber = NOOP; }\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    var isActive = false;\r\n    var isDisposed = false;\r\n    var value = initialValue;\r\n    var suspender = function () {\r\n        if (isActive) {\r\n            isActive = false;\r\n            unsubscriber();\r\n        }\r\n    };\r\n    var atom = createAtom(\"ResourceBasedObservable\", function () {\r\n        invariant(!isActive && !isDisposed);\r\n        isActive = true;\r\n        subscriber(function (newValue) {\r\n            _allowStateChanges(true, function () {\r\n                value = newValue;\r\n                atom.reportChanged();\r\n            });\r\n        });\r\n    }, suspender);\r\n    return {\r\n        current: function () {\r\n            invariant(!isDisposed, \"subscribingObservable has already been disposed\");\r\n            var isBeingTracked = atom.reportObserved();\r\n            if (!isBeingTracked && !isActive)\r\n                console.warn(\"Called `get` of a subscribingObservable outside a reaction. Current value will be returned but no new subscription has started\");\r\n            return value;\r\n        },\r\n        dispose: function () {\r\n            isDisposed = true;\r\n            suspender();\r\n        },\r\n        isAlive: function () { return isActive; },\r\n    };\r\n}\n\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nfunction observableSymbol() {\r\n    return (typeof Symbol === \"function\" && Symbol.observable) || \"@@observable\";\r\n}\r\n/**\r\n * Converts an expression to an observable stream (a.k.a. TC 39 Observable / RxJS observable).\r\n * The provided expression is tracked by mobx as long as there are subscribers, automatically\r\n * emitting when new values become available. The expressions respect (trans)actions.\r\n *\r\n * @example\r\n *\r\n * const user = observable({\r\n *   firstName: \"C.S\",\r\n *   lastName: \"Lewis\"\r\n * })\r\n *\r\n * Rx.Observable\r\n *   .from(mobxUtils.toStream(() => user.firstname + user.lastName))\r\n *   .scan(nameChanges => nameChanges + 1, 0)\r\n *   .subscribe(nameChanges => console.log(\"Changed name \", nameChanges, \"times\"))\r\n *\r\n * @export\r\n * @template T\r\n * @param {() => T} expression\r\n * @param {boolean} fireImmediately (by default false)\r\n * @returns {IObservableStream<T>}\r\n */\r\nfunction toStream(expression, fireImmediately) {\r\n    var _a;\r\n    if (fireImmediately === void 0) { fireImmediately = false; }\r\n    var computedValue = computed(expression);\r\n    return _a = {\r\n            subscribe: function (observer) {\r\n                if (\"function\" === typeof observer) {\r\n                    return {\r\n                        unsubscribe: computedValue.observe(function (_a) {\r\n                            var newValue = _a.newValue;\r\n                            return observer(newValue);\r\n                        }, fireImmediately),\r\n                    };\r\n                }\r\n                if (observer && \"object\" === typeof observer && observer.next) {\r\n                    return {\r\n                        unsubscribe: computedValue.observe(function (_a) {\r\n                            var newValue = _a.newValue;\r\n                            return observer.next(newValue);\r\n                        }, fireImmediately),\r\n                    };\r\n                }\r\n                return {\r\n                    unsubscribe: function () { },\r\n                };\r\n            }\r\n        },\r\n        _a[observableSymbol()] = function () {\r\n            return this;\r\n        },\r\n        _a;\r\n}\r\nvar StreamListener = /** @class */ (function () {\r\n    function StreamListener(observable, initialValue) {\r\n        var _this = this;\r\n        runInAction(function () {\r\n            _this.current = initialValue;\r\n            _this.subscription = observable.subscribe(_this);\r\n        });\r\n    }\r\n    StreamListener.prototype.dispose = function () {\r\n        if (this.subscription) {\r\n            this.subscription.unsubscribe();\r\n        }\r\n    };\r\n    StreamListener.prototype.next = function (value) {\r\n        this.current = value;\r\n    };\r\n    StreamListener.prototype.complete = function () {\r\n        this.dispose();\r\n    };\r\n    StreamListener.prototype.error = function (value) {\r\n        this.current = value;\r\n        this.dispose();\r\n    };\r\n    __decorate([\r\n        observable.ref\r\n    ], StreamListener.prototype, \"current\", void 0);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"next\", null);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"complete\", null);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"error\", null);\r\n    return StreamListener;\r\n}());\r\nfunction fromStream(observable, initialValue) {\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    return new StreamListener(observable, initialValue);\r\n}\n\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar RESERVED_NAMES = [\"model\", \"reset\", \"submit\", \"isDirty\", \"isPropertyDirty\", \"resetProperty\"];\r\nvar ViewModel = /** @class */ (function () {\r\n    function ViewModel(model) {\r\n        var _this = this;\r\n        this.model = model;\r\n        this.localValues = observable.map({});\r\n        this.localComputedValues = observable.map({});\r\n        this.isPropertyDirty = function (key) {\r\n            return _this.localValues.has(key);\r\n        };\r\n        invariant(isObservableObject(model), \"createViewModel expects an observable object\");\r\n        // use this helper as Object.getOwnPropertyNames doesn't return getters\r\n        getAllMethodsAndProperties(model).forEach(function (key) {\r\n            if (key === $mobx || key === \"__mobxDidRunLazyInitializers\") {\r\n                return;\r\n            }\r\n            invariant(RESERVED_NAMES.indexOf(key) === -1, \"The propertyname \" + key + \" is reserved and cannot be used with viewModels\");\r\n            if (isComputedProp(model, key)) {\r\n                var derivation = _getAdministration(model, key).derivation; // Fixme: there is no clear api to get the derivation\r\n                _this.localComputedValues.set(key, computed(derivation.bind(_this)));\r\n            }\r\n            var descriptor = Object.getOwnPropertyDescriptor(model, key);\r\n            var additionalDescriptor = descriptor ? { enumerable: descriptor.enumerable } : {};\r\n            Object.defineProperty(_this, key, __assign(__assign({}, additionalDescriptor), { configurable: true, get: function () {\r\n                    if (isComputedProp(model, key))\r\n                        return _this.localComputedValues.get(key).get();\r\n                    if (_this.isPropertyDirty(key))\r\n                        return _this.localValues.get(key);\r\n                    else\r\n                        return _this.model[key];\r\n                }, set: action(function (value) {\r\n                    if (value !== _this.model[key]) {\r\n                        _this.localValues.set(key, value);\r\n                    }\r\n                    else {\r\n                        _this.localValues.delete(key);\r\n                    }\r\n                }) }));\r\n        });\r\n    }\r\n    Object.defineProperty(ViewModel.prototype, \"isDirty\", {\r\n        get: function () {\r\n            return this.localValues.size > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ViewModel.prototype, \"changedValues\", {\r\n        get: function () {\r\n            return this.localValues.toJS();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    ViewModel.prototype.submit = function () {\r\n        var _this = this;\r\n        keys(this.localValues).forEach(function (key) {\r\n            var source = _this.localValues.get(key);\r\n            var destination = _this.model[key];\r\n            if (isObservableArray(destination)) {\r\n                destination.replace(source);\r\n            }\r\n            else if (isObservableMap(destination)) {\r\n                destination.clear();\r\n                destination.merge(source);\r\n            }\r\n            else if (!isComputed(source)) {\r\n                _this.model[key] = source;\r\n            }\r\n        });\r\n        this.localValues.clear();\r\n    };\r\n    ViewModel.prototype.reset = function () {\r\n        this.localValues.clear();\r\n    };\r\n    ViewModel.prototype.resetProperty = function (key) {\r\n        this.localValues.delete(key);\r\n    };\r\n    __decorate$1([\r\n        computed\r\n    ], ViewModel.prototype, \"isDirty\", null);\r\n    __decorate$1([\r\n        computed\r\n    ], ViewModel.prototype, \"changedValues\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"submit\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"reset\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"resetProperty\", null);\r\n    return ViewModel;\r\n}());\r\n/**\r\n * `createViewModel` takes an object with observable properties (model)\r\n * and wraps a viewmodel around it. The viewmodel proxies all enumerable properties of the original model with the following behavior:\r\n *  - as long as no new value has been assigned to the viewmodel property, the original property will be returned.\r\n *  - any future change in the model will be visible in the viewmodel as well unless the viewmodel property was dirty at the time of the attempted change.\r\n *  - once a new value has been assigned to a property of the viewmodel, that value will be returned during a read of that property in the future. However, the original model remain untouched until `submit()` is called.\r\n *\r\n * The viewmodel exposes the following additional methods, besides all the enumerable properties of the model:\r\n * - `submit()`: copies all the values of the viewmodel to the model and resets the state\r\n * - `reset()`: resets the state of the viewmodel, abandoning all local modifications\r\n * - `resetProperty(propName)`: resets the specified property of the viewmodel\r\n * - `isDirty`: observable property indicating if the viewModel contains any modifications\r\n * - `isPropertyDirty(propName)`: returns true if the specified property is dirty\r\n * - `changedValues`: returns a key / value map with the properties that have been changed in the model so far\r\n * - `model`: The original model object for which this viewModel was created\r\n *\r\n * You may use observable arrays, maps and objects with `createViewModel` but keep in mind to assign fresh instances of those to the viewmodel's properties, otherwise you would end up modifying the properties of the original model.\r\n * Note that if you read a non-dirty property, viewmodel only proxies the read to the model. You therefore need to assign a fresh instance not only the first time you make the assignment but also after calling `reset()` or `submit()`.\r\n *\r\n * @example\r\n * class Todo {\r\n *   \\@observable title = \"Test\"\r\n * }\r\n *\r\n * const model = new Todo()\r\n * const viewModel = createViewModel(model);\r\n *\r\n * autorun(() => console.log(viewModel.model.title, \",\", viewModel.title))\r\n * // prints \"Test, Test\"\r\n * model.title = \"Get coffee\"\r\n * // prints \"Get coffee, Get coffee\", viewModel just proxies to model\r\n * viewModel.title = \"Get tea\"\r\n * // prints \"Get coffee, Get tea\", viewModel's title is now dirty, and the local value will be printed\r\n * viewModel.submit()\r\n * // prints \"Get tea, Get tea\", changes submitted from the viewModel to the model, viewModel is proxying again\r\n * viewModel.title = \"Get cookie\"\r\n * // prints \"Get tea, Get cookie\" // viewModel has diverged again\r\n * viewModel.reset()\r\n * // prints \"Get tea, Get tea\", changes of the viewModel have been abandoned\r\n *\r\n * @param {T} model\r\n * @returns {(T & IViewModel<T>)}\r\n * ```\r\n */\r\nfunction createViewModel(model) {\r\n    return new ViewModel(model);\r\n}\n\n/**\r\n * Like normal `when`, except that this `when` will automatically dispose if the condition isn't met within a certain amount of time.\r\n *\r\n * @example\r\n * test(\"expect store to load\", t => {\r\n *   const store = {\r\n *     items: [],\r\n *     loaded: false\r\n *   }\r\n *   fetchDataForStore((data) => {\r\n *     store.items = data;\r\n *     store.loaded = true;\r\n *   })\r\n *   whenWithTimeout(\r\n *     () => store.loaded\r\n *     () => t.end()\r\n *     2000,\r\n *     () => t.fail(\"store didn't load with 2 secs\")\r\n *   )\r\n * })\r\n *\r\n *\r\n * @export\r\n * @param {() => boolean} expr see when, the expression to await\r\n * @param {() => void} action see when, the action to execut when expr returns truthy\r\n * @param {number} [timeout=10000] maximum amount when spends waiting before giving up\r\n * @param {any} [onTimeout=() => {}] the ontimeout handler will be called if the condition wasn't met within the given time\r\n * @returns {IDisposer} disposer function that can be used to cancel the when prematurely. Neither action or onTimeout will be fired if disposed\r\n */\r\nfunction whenWithTimeout(expr, action, timeout, onTimeout) {\r\n    if (timeout === void 0) { timeout = 10000; }\r\n    if (onTimeout === void 0) { onTimeout = function () { }; }\r\n    deprecated(\"whenWithTimeout is deprecated, use mobx.when with timeout option instead\");\r\n    return when(expr, action, {\r\n        timeout: timeout,\r\n        onError: onTimeout,\r\n    });\r\n}\n\n/**\r\n * MobX normally suspends any computed value that is not in use by any reaction,\r\n * and lazily re-evaluates the expression if needed outside a reaction while not in use.\r\n * `keepAlive` marks a computed value as always in use, meaning that it will always fresh, but never disposed automatically.\r\n *\r\n * @example\r\n * const obj = observable({\r\n *   number: 3,\r\n *   doubler: function() { return this.number * 2 }\r\n * })\r\n * const stop = keepAlive(obj, \"doubler\")\r\n *\r\n * @param {Object} target an object that has a computed property, created by `@computed` or `extendObservable`\r\n * @param {string} property the name of the property to keep alive\r\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\r\n */\r\n/**\r\n * @example\r\n * const number = observable(3)\r\n * const doubler = computed(() => number.get() * 2)\r\n * const stop = keepAlive(doubler)\r\n * // doubler will now stay in sync reactively even when there are no further observers\r\n * stop()\r\n * // normal behavior, doubler results will be recomputed if not observed but needed, but lazily\r\n *\r\n * @param {IComputedValue<any>} computedValue created using the `computed` function\r\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\r\n */\r\nfunction keepAlive(_1, _2) {\r\n    var computed = getAtom(_1, _2);\r\n    if (!computed)\r\n        throw new Error(\"No computed provided, please provide an object created with `computed(() => expr)` or an object + property name\");\r\n    return computed.observe(function () { });\r\n}\n\n/**\r\n * `queueProcessor` takes an observable array, observes it and calls `processor`\r\n * once for each item added to the observable array, optionally debouncing the action\r\n *\r\n * @example\r\n * const pendingNotifications = observable([])\r\n * const stop = queueProcessor(pendingNotifications, msg => {\r\n *   // show Desktop notification\r\n *   new Notification(msg);\r\n * })\r\n *\r\n * // usage:\r\n * pendingNotifications.push(\"test!\")\r\n *\r\n * @param {T[]} observableArray observable array instance to track\r\n * @param {(item: T) => void} processor action to call per item\r\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\r\n * @returns {IDisposer} stops the processor\r\n */\r\nfunction queueProcessor(observableArray, processor, debounce) {\r\n    if (debounce === void 0) { debounce = 0; }\r\n    if (!isObservableArray(observableArray))\r\n        throw new Error(\"Expected observable array as first argument\");\r\n    if (!isAction(processor))\r\n        processor = action(\"queueProcessor\", processor);\r\n    var runner = function () {\r\n        // construct a final set\r\n        var items = observableArray.slice(0);\r\n        // clear the queue for next iteration\r\n        runInAction(function () { return observableArray.splice(0); });\r\n        // fire processor\r\n        items.forEach(processor);\r\n    };\r\n    if (debounce > 0)\r\n        return autorun(runner, { delay: debounce });\r\n    else\r\n        return autorun(runner);\r\n}\n\n/**\r\n * `chunkProcessor` takes an observable array, observes it and calls `processor`\r\n * once for a chunk of items added to the observable array, optionally deboucing the action.\r\n * The maximum chunk size can be limited by number.\r\n * This allows both, splitting larger into smaller chunks or (when debounced) combining smaller\r\n * chunks and/or single items into reasonable chunks of work.\r\n *\r\n * @example\r\n * const trackedActions = observable([])\r\n * const stop = chunkProcessor(trackedActions, chunkOfMax10Items => {\r\n *   sendTrackedActionsToServer(chunkOfMax10Items);\r\n * }, 100, 10)\r\n *\r\n * // usage:\r\n * trackedActions.push(\"scrolled\")\r\n * trackedActions.push(\"hoveredButton\")\r\n * // when both pushes happen within 100ms, there will be only one call to server\r\n *\r\n * @param {T[]} observableArray observable array instance to track\r\n * @param {(item: T[]) => void} processor action to call per item\r\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\r\n * @param {number} [maxChunkSize=0] optionally do not call on full array but smaller chunks. With 0 it will process the full array.\r\n * @returns {IDisposer} stops the processor\r\n */\r\nfunction chunkProcessor(observableArray, processor, debounce, maxChunkSize) {\r\n    if (debounce === void 0) { debounce = 0; }\r\n    if (maxChunkSize === void 0) { maxChunkSize = 0; }\r\n    if (!isObservableArray(observableArray))\r\n        throw new Error(\"Expected observable array as first argument\");\r\n    if (!isAction(processor))\r\n        processor = action(\"chunkProcessor\", processor);\r\n    var runner = function () {\r\n        var _loop_1 = function () {\r\n            var chunkSize = maxChunkSize === 0\r\n                ? observableArray.length\r\n                : Math.min(observableArray.length, maxChunkSize);\r\n            // construct a final set\r\n            var items = observableArray.slice(0, chunkSize);\r\n            // clear the slice for next iteration\r\n            runInAction(function () { return observableArray.splice(0, chunkSize); });\r\n            // fire processor\r\n            processor(items);\r\n        };\r\n        while (observableArray.length > 0) {\r\n            _loop_1();\r\n        }\r\n    };\r\n    if (debounce > 0)\r\n        return autorun(runner, { delay: debounce });\r\n    else\r\n        return autorun(runner);\r\n}\n\nvar tickers = {};\r\n/**\r\n * Returns the current date time as epoch number.\r\n * The date time is read from an observable which is updated automatically after the given interval.\r\n * So basically it treats time as an observable.\r\n *\r\n * The function takes an interval as parameter, which indicates how often `now()` will return a new value.\r\n * If no interval is given, it will update each second. If \"frame\" is specified, it will update each time a\r\n * `requestAnimationFrame` is available.\r\n *\r\n * Multiple clocks with the same interval will automatically be synchronized.\r\n *\r\n * Countdown example: https://jsfiddle.net/mweststrate/na0qdmkw/\r\n *\r\n * @example\r\n *\r\n * const start = Date.now()\r\n *\r\n * autorun(() => {\r\n *   console.log(\"Seconds elapsed: \", (mobxUtils.now() - start) / 1000)\r\n * })\r\n *\r\n *\r\n * @export\r\n * @param {(number | \"frame\")} [interval=1000] interval in milliseconds about how often the interval should update\r\n * @returns\r\n */\r\nfunction now(interval) {\r\n    if (interval === void 0) { interval = 1000; }\r\n    if (!_isComputingDerivation()) {\r\n        // See #40\r\n        return Date.now();\r\n    }\r\n    if (!tickers[interval]) {\r\n        if (typeof interval === \"number\")\r\n            tickers[interval] = createIntervalTicker(interval);\r\n        else\r\n            tickers[interval] = createAnimationFrameTicker();\r\n    }\r\n    return tickers[interval].current();\r\n}\r\nfunction createIntervalTicker(interval) {\r\n    var subscriptionHandle;\r\n    return fromResource(function (sink) {\r\n        subscriptionHandle = setInterval(function () { return sink(Date.now()); }, interval);\r\n    }, function () {\r\n        clearInterval(subscriptionHandle);\r\n    }, Date.now());\r\n}\r\nfunction createAnimationFrameTicker() {\r\n    var frameBasedTicker = fromResource(function (sink) {\r\n        function scheduleTick() {\r\n            window.requestAnimationFrame(function () {\r\n                sink(Date.now());\r\n                if (frameBasedTicker.isAlive())\r\n                    scheduleTick();\r\n            });\r\n        }\r\n        scheduleTick();\r\n    }, function () { }, Date.now());\r\n    return frameBasedTicker;\r\n}\n\nvar __assign$1 = (undefined && undefined.__assign) || function () {\r\n    __assign$1 = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$1.apply(this, arguments);\r\n};\r\n/**\r\n * _deprecated_ this functionality can now be found as `flow` in the mobx package. However, `flow` is not applicable as decorator, where `asyncAction` still is.\r\n *\r\n *\r\n *\r\n * `asyncAction` takes a generator function and automatically wraps all parts of the process in actions. See the examples below.\r\n * `asyncAction` can be used both as decorator or to wrap functions.\r\n *\r\n * - It is important that `asyncAction should always be used with a generator function (recognizable as `function*` or `*name` syntax)\r\n * - Each yield statement should return a Promise. The generator function will continue as soon as the promise settles, with the settled value\r\n * - When the generator function finishes, you can return a normal value. The `asyncAction` wrapped function will always produce a promise delivering that value.\r\n *\r\n * When using the mobx devTools, an asyncAction will emit `action` events with names like:\r\n * * `\"fetchUsers - runid: 6 - init\"`\r\n * * `\"fetchUsers - runid: 6 - yield 0\"`\r\n * * `\"fetchUsers - runid: 6 - yield 1\"`\r\n *\r\n * The `runId` represents the generator instance. In other words, if `fetchUsers` is invoked multiple times concurrently, the events with the same `runid` belong together.\r\n * The `yield` number indicates the progress of the generator. `init` indicates spawning (it won't do anything, but you can find the original arguments of the `asyncAction` here).\r\n * `yield 0` ... `yield n` indicates the code block that is now being executed. `yield 0` is before the first `yield`, `yield 1` after the first one etc. Note that yield numbers are not determined lexically but by the runtime flow.\r\n *\r\n * `asyncActions` requires `Promise` and `generators` to be available on the target environment. Polyfill `Promise` if needed. Both TypeScript and Babel can compile generator functions down to ES5.\r\n *\r\n *  N.B. due to a [babel limitation](https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy/issues/26), in Babel generatos cannot be combined with decorators. See also [#70](https://github.com/mobxjs/mobx-utils/issues/70)\r\n *\r\n *\r\n * @example\r\n * import {asyncAction} from \"mobx-utils\"\r\n *\r\n * let users = []\r\n *\r\n * const fetchUsers = asyncAction(\"fetchUsers\", function* (url) {\r\n *   const start = Date.now()\r\n *   const data = yield window.fetch(url)\r\n *   users = yield data.json()\r\n *   return start - Date.now()\r\n * })\r\n *\r\n * fetchUsers(\"http://users.com\").then(time => {\r\n *   console.dir(\"Got users\", users, \"in \", time, \"ms\")\r\n * })\r\n *\r\n * @example\r\n * import {asyncAction} from \"mobx-utils\"\r\n *\r\n * mobx.configure({ enforceActions: \"observed\" }) // don't allow state modifications outside actions\r\n *\r\n * class Store {\r\n * \t\\@observable githubProjects = []\r\n * \t\\@observable = \"pending\" // \"pending\" / \"done\" / \"error\"\r\n *\r\n * \t\\@asyncAction\r\n * \t*fetchProjects() { // <- note the star, this a generator function!\r\n * \t\tthis.githubProjects = []\r\n * \t\tthis.state = \"pending\"\r\n * \t\ttry {\r\n * \t\t\tconst projects = yield fetchGithubProjectsSomehow() // yield instead of await\r\n * \t\t\tconst filteredProjects = somePreprocessing(projects)\r\n * \t\t\t// the asynchronous blocks will automatically be wrapped actions\r\n * \t\t\tthis.state = \"done\"\r\n * \t\t\tthis.githubProjects = filteredProjects\r\n * \t\t} catch (error) {\r\n * \t\t\tthis.state = \"error\"\r\n * \t\t}\r\n * \t}\r\n * }\r\n *\r\n * @export\r\n * @returns {Promise}\r\n */\r\nfunction asyncAction(arg1, arg2) {\r\n    // decorator\r\n    if (typeof arguments[1] === \"string\") {\r\n        var name_1 = arguments[1];\r\n        var descriptor_1 = arguments[2];\r\n        if (descriptor_1 && descriptor_1.value) {\r\n            return Object.assign({}, descriptor_1, {\r\n                value: flow(descriptor_1.value),\r\n            });\r\n        }\r\n        else {\r\n            return Object.assign({}, descriptor_1, {\r\n                set: function (v) {\r\n                    Object.defineProperty(this, name_1, __assign$1(__assign$1({}, descriptor_1), { value: flow(v) }));\r\n                },\r\n            });\r\n        }\r\n    }\r\n    // direct invocation\r\n    var generator = typeof arg1 === \"string\" ? arg2 : arg1;\r\n    var name = typeof arg1 === \"string\" ? arg1 : generator.name || \"<unnamed async action>\";\r\n    deprecated(\"asyncAction is deprecated. use mobx.flow instead\");\r\n    return flow(generator); // name get's dropped..\r\n}\n\n/**\r\n * _deprecated_ whenAsync is deprecated, use mobx.when without effect instead.\r\n *\r\n * Like normal `when`, except that this `when` will return a promise that resolves when the expression becomes truthy\r\n *\r\n * @example\r\n * await whenAsync(() => !state.someBoolean)\r\n *\r\n * @export\r\n * @param {() => boolean} fn see when, the expression to await\r\n * @param {number} timeout maximum amount of time to wait, before the promise rejects\r\n * @returns Promise for when an observable eventually matches some condition. Rejects if timeout is provided and has expired\r\n */\r\nfunction whenAsync(fn, timeout) {\r\n    if (timeout === void 0) { timeout = 0; }\r\n    deprecated(\"whenAsync is deprecated, use mobx.when without effect instead\");\r\n    return when(fn, {\r\n        timeout: timeout,\r\n    });\r\n}\n\n/**\r\n * expr can be used to create temporarily views inside views.\r\n * This can be improved to improve performance if a value changes often, but usually doesn't affect the outcome of an expression.\r\n *\r\n * In the following example the expression prevents that a component is rerender _each time_ the selection changes;\r\n * instead it will only rerenders when the current todo is (de)selected.\r\n *\r\n * @example\r\n * const Todo = observer((props) => {\r\n *     const todo = props.todo;\r\n *     const isSelected = mobxUtils.expr(() => props.viewState.selection === todo);\r\n *     return <div className={isSelected ? \"todo todo-selected\" : \"todo\"}>{todo.title}</div>\r\n * });\r\n *\r\n */\r\nfunction expr(expr) {\r\n    if (!_isComputingDerivation())\r\n        console.warn(\"'expr' should only be used inside other reactive functions.\");\r\n    // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired\r\n    return computed(expr).get();\r\n}\n\nvar __assign$2 = (undefined && undefined.__assign) || function () {\r\n    __assign$2 = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$2.apply(this, arguments);\r\n};\r\nvar memoizationId = 0;\r\nfunction createTransformer(transformer, arg2) {\r\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\r\n    // Memoizes: object id -> reactive view that applies transformer to the object\r\n    var views = {};\r\n    var onCleanup = undefined;\r\n    var keepAlive = false;\r\n    var debugNameGenerator = undefined;\r\n    if (typeof arg2 === \"object\") {\r\n        onCleanup = arg2.onCleanup;\r\n        keepAlive = arg2.keepAlive !== undefined ? arg2.keepAlive : false;\r\n        debugNameGenerator = arg2.debugNameGenerator;\r\n    }\r\n    else if (typeof arg2 === \"function\") {\r\n        onCleanup = arg2;\r\n    }\r\n    function createView(sourceIdentifier, sourceObject) {\r\n        var latestValue;\r\n        var computedValueOptions = {};\r\n        if (typeof arg2 === \"object\") {\r\n            onCleanup = arg2.onCleanup;\r\n            debugNameGenerator = arg2.debugNameGenerator;\r\n            computedValueOptions = arg2;\r\n        }\r\n        else if (typeof arg2 === \"function\") {\r\n            onCleanup = arg2;\r\n        }\r\n        else {\r\n            onCleanup = undefined;\r\n            debugNameGenerator = undefined;\r\n        }\r\n        var prettifiedName = debugNameGenerator\r\n            ? debugNameGenerator(sourceObject)\r\n            : \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier;\r\n        var expr = computed(function () {\r\n            return (latestValue = transformer(sourceObject));\r\n        }, __assign$2(__assign$2({}, computedValueOptions), { name: prettifiedName }));\r\n        if (!keepAlive) {\r\n            var disposer_1 = onBecomeUnobserved(expr, function () {\r\n                delete views[sourceIdentifier];\r\n                disposer_1();\r\n                if (onCleanup)\r\n                    onCleanup(latestValue, sourceObject);\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n    var memoWarned = false;\r\n    return function (object) {\r\n        var identifier = getMemoizationId(object);\r\n        var reactiveView = views[identifier];\r\n        if (reactiveView)\r\n            return reactiveView.get();\r\n        if (!keepAlive && !_isComputingDerivation()) {\r\n            if (!memoWarned) {\r\n                console.warn(\"invoking a transformer from outside a reactive context won't memorized \" +\r\n                    \"and is cleaned up immediately, unless keepAlive is set\");\r\n                memoWarned = true;\r\n            }\r\n            var value = transformer(object);\r\n            if (onCleanup)\r\n                onCleanup(value, object);\r\n            return value;\r\n        }\r\n        // Not in cache; create a reactive view\r\n        reactiveView = views[identifier] = createView(identifier, object);\r\n        return reactiveView.get();\r\n    };\r\n}\r\nfunction getMemoizationId(object) {\r\n    var objectType = typeof object;\r\n    if (objectType === \"string\")\r\n        return \"string:\" + object;\r\n    if (objectType === \"number\")\r\n        return \"number:\" + object;\r\n    if (object === null || (objectType !== \"object\" && objectType !== \"function\"))\r\n        throw new Error(\"[mobx-utils] transform expected an object, function, string or number, got: \" + String(object));\r\n    var tid = object.$transformId;\r\n    if (tid === undefined) {\r\n        tid = \"memoizationId:\" + ++memoizationId;\r\n        addHiddenProp(object, \"$transformId\", tid);\r\n    }\r\n    return tid;\r\n}\n\nfunction buildPath(entry) {\r\n    if (!entry)\r\n        return \"ROOT\";\r\n    var res = [];\r\n    while (entry.parent) {\r\n        res.push(entry.path);\r\n        entry = entry.parent;\r\n    }\r\n    return res.reverse().join(\"/\");\r\n}\r\nfunction isRecursivelyObservable(thing) {\r\n    return isObservableObject(thing) || isObservableArray(thing) || isObservableMap(thing);\r\n}\r\n/**\r\n * Given an object, deeply observes the given object.\r\n * It is like `observe` from mobx, but applied recursively, including all future children.\r\n *\r\n * Note that the given object cannot ever contain cycles and should be a tree.\r\n *\r\n * As benefit: path and root will be provided in the callback, so the signature of the listener is\r\n * (change, path, root) => void\r\n *\r\n * The returned disposer can be invoked to clean up the listener\r\n *\r\n * deepObserve cannot be used on computed values.\r\n *\r\n * @example\r\n * const disposer = deepObserve(target, (change, path) => {\r\n *    console.dir(change)\r\n * })\r\n */\r\nfunction deepObserve(target, listener) {\r\n    var entrySet = new WeakMap();\r\n    function genericListener(change) {\r\n        var entry = entrySet.get(change.object);\r\n        processChange(change, entry);\r\n        listener(change, buildPath(entry), target);\r\n    }\r\n    function processChange(change, parent) {\r\n        switch (change.type) {\r\n            // Object changes\r\n            case \"add\": // also for map\r\n                observeRecursively(change.newValue, parent, change.name);\r\n                break;\r\n            case \"update\": // also for array and map\r\n                unobserveRecursively(change.oldValue);\r\n                observeRecursively(change.newValue, parent, change.name || \"\" + change.index);\r\n                break;\r\n            case \"remove\": // object\r\n            case \"delete\": // map\r\n                unobserveRecursively(change.oldValue);\r\n                break;\r\n            // Array changes\r\n            case \"splice\":\r\n                change.removed.map(unobserveRecursively);\r\n                change.added.forEach(function (value, idx) {\r\n                    return observeRecursively(value, parent, \"\" + (change.index + idx));\r\n                });\r\n                // update paths\r\n                for (var i = change.index + change.addedCount; i < change.object.length; i++) {\r\n                    if (isRecursivelyObservable(change.object[i])) {\r\n                        var entry = entrySet.get(change.object[i]);\r\n                        if (entry)\r\n                            entry.path = \"\" + i;\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    function observeRecursively(thing, parent, path) {\r\n        if (isRecursivelyObservable(thing)) {\r\n            var entry = entrySet.get(thing);\r\n            if (entry) {\r\n                if (entry.parent !== parent || entry.path !== path)\r\n                    // MWE: this constraint is artificial, and this tool could be made to work with cycles,\r\n                    // but it increases administration complexity, has tricky edge cases and the meaning of 'path'\r\n                    // would become less clear. So doesn't seem to be needed for now\r\n                    throw new Error(\"The same observable object cannot appear twice in the same tree,\" +\r\n                        (\" trying to assign it to '\" + buildPath(parent) + \"/\" + path + \"',\") +\r\n                        (\" but it already exists at '\" + buildPath(entry.parent) + \"/\" + entry.path + \"'\"));\r\n            }\r\n            else {\r\n                var entry_1 = {\r\n                    parent: parent,\r\n                    path: path,\r\n                    dispose: observe(thing, genericListener),\r\n                };\r\n                entrySet.set(thing, entry_1);\r\n                entries(thing).forEach(function (_a) {\r\n                    var key = _a[0], value = _a[1];\r\n                    return observeRecursively(value, entry_1, key);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    function unobserveRecursively(thing) {\r\n        if (isRecursivelyObservable(thing)) {\r\n            var entry = entrySet.get(thing);\r\n            if (!entry)\r\n                return;\r\n            entrySet.delete(thing);\r\n            entry.dispose();\r\n            values(thing).forEach(unobserveRecursively);\r\n        }\r\n    }\r\n    observeRecursively(target, undefined, \"\");\r\n    return function () {\r\n        unobserveRecursively(target);\r\n    };\r\n}\n\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/**\r\n * Reactively sorts a base observable array into multiple observable arrays based on the value of a\r\n * `groupBy: (item: T) => G` function.\r\n *\r\n * This observes the individual computed groupBy values and only updates the source and dest arrays\r\n * when there is an actual change, so this is far more efficient than, for example\r\n * `base.filter(i => groupBy(i) === 'we')`. Call #dispose() to stop tracking.\r\n *\r\n * No guarantees are made about the order of items in the grouped arrays.\r\n *\r\n * The resulting map of arrays is read-only. clear(), set(), delete() are not supported and\r\n * modifying the group arrays will lead to undefined behavior.\r\n *\r\n * @param {array} base The array to sort into groups.\r\n * @param {function} groupBy The function used for grouping.\r\n * @param options Object with properties:\r\n *  `name`: Debug name of this ObservableGroupMap.\r\n *  `keyToName`: Function to create the debug names of the observable group arrays.\r\n *\r\n * @example\r\n * const slices = observable([\r\n *     { day: \"mo\", hours: 12 },\r\n *     { day: \"tu\", hours: 2 },\r\n * ])\r\n * const slicesByDay = new ObservableGroupMap(slices, (slice) => slice.day)\r\n * autorun(() => console.log(\r\n *     slicesByDay.get(\"mo\")?.length ?? 0,\r\n *     slicesByDay.get(\"we\"))) // outputs 1, undefined\r\n * slices[0].day = \"we\" // outputs 0, [{ day: \"we\", hours: 12 }]\r\n */\r\nvar ObservableGroupMap = /** @class */ (function (_super) {\r\n    __extends(ObservableGroupMap, _super);\r\n    function ObservableGroupMap(base, groupBy, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.name, name = _c === void 0 ? \"ogm\" + ((Math.random() * 1000) | 0) : _c, _d = _b.keyToName, keyToName = _d === void 0 ? function (x) { return \"\" + x; } : _d;\r\n        var _this = _super.call(this) || this;\r\n        _this._keyToName = keyToName;\r\n        _this._groupBy = groupBy;\r\n        _this._ogmInfoKey = (\"function\" == typeof Symbol\r\n            ? Symbol(\"ogmInfo\" + name)\r\n            : \"__ogmInfo\" + name);\r\n        _this._base = base;\r\n        for (var i = 0; i < base.length; i++) {\r\n            _this._addItem(base[i]);\r\n        }\r\n        _this._disposeBaseObserver = observe(_this._base, function (change) {\r\n            if (\"splice\" === change.type) {\r\n                transaction(function () {\r\n                    for (var _i = 0, _a = change.removed; _i < _a.length; _i++) {\r\n                        var removed = _a[_i];\r\n                        _this._removeItem(removed);\r\n                    }\r\n                    for (var _b = 0, _c = change.added; _b < _c.length; _b++) {\r\n                        var added = _c[_b];\r\n                        _this._addItem(added);\r\n                    }\r\n                });\r\n            }\r\n            else if (\"update\" === change.type) {\r\n                transaction(function () {\r\n                    _this._removeItem(change.oldValue);\r\n                    _this._addItem(change.newValue);\r\n                });\r\n            }\r\n            else {\r\n                throw new Error(\"illegal state\");\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    ObservableGroupMap.prototype.clear = function () {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    ObservableGroupMap.prototype.delete = function (_key) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    ObservableGroupMap.prototype.set = function (_key, _value) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    /**\r\n     * Disposes all observers created during construction and removes state added to base array\r\n     * items.\r\n     */\r\n    ObservableGroupMap.prototype.dispose = function () {\r\n        this._disposeBaseObserver();\r\n        for (var i = 0; i < this._base.length; i++) {\r\n            var item = this._base[i];\r\n            var grouperItemInfo = item[this._ogmInfoKey];\r\n            grouperItemInfo.reaction();\r\n            delete item[this._ogmInfoKey];\r\n        }\r\n    };\r\n    ObservableGroupMap.prototype._getGroupArr = function (key) {\r\n        var result = _super.prototype.get.call(this, key);\r\n        if (undefined === result) {\r\n            result = observable([], { name: \"GroupArray[\" + this._keyToName(key) + \"]\" });\r\n            _super.prototype.set.call(this, key, result);\r\n        }\r\n        return result;\r\n    };\r\n    ObservableGroupMap.prototype._removeFromGroupArr = function (key, itemIndex) {\r\n        var arr = _super.prototype.get.call(this, key);\r\n        if (1 === arr.length) {\r\n            _super.prototype.delete.call(this, key);\r\n        }\r\n        else if (itemIndex === arr.length - 1) {\r\n            // last position in array\r\n            arr.length--;\r\n        }\r\n        else {\r\n            arr[itemIndex] = arr[arr.length - 1];\r\n            arr[itemIndex][this._ogmInfoKey].groupArrIndex = itemIndex;\r\n            arr.length--;\r\n        }\r\n    };\r\n    ObservableGroupMap.prototype._addItem = function (item) {\r\n        var _this = this;\r\n        var groupByValue = this._groupBy(item);\r\n        var groupArr = this._getGroupArr(groupByValue);\r\n        var value = {\r\n            groupByValue: groupByValue,\r\n            groupArrIndex: groupArr.length,\r\n            reaction: reaction(function () { return _this._groupBy(item); }, function (newGroupByValue, _r) {\r\n                console.log(\"new group by value \", newGroupByValue);\r\n                var grouperItemInfo = item[_this._ogmInfoKey];\r\n                _this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\r\n                var newGroupArr = _this._getGroupArr(newGroupByValue);\r\n                var newGroupArrIndex = newGroupArr.length;\r\n                newGroupArr.push(item);\r\n                grouperItemInfo.groupByValue = newGroupByValue;\r\n                grouperItemInfo.groupArrIndex = newGroupArrIndex;\r\n            }),\r\n        };\r\n        Object.defineProperty(item, this._ogmInfoKey, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            value: value,\r\n        });\r\n        groupArr.push(item);\r\n    };\r\n    ObservableGroupMap.prototype._removeItem = function (item) {\r\n        var grouperItemInfo = item[this._ogmInfoKey];\r\n        this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\r\n        grouperItemInfo.reaction();\r\n        delete item[this._ogmInfoKey];\r\n    };\r\n    return ObservableGroupMap;\r\n}(ObservableMap));\n\n/**\r\n * @private\r\n */\r\nvar DeepMapEntry = /** @class */ (function () {\r\n    function DeepMapEntry(base, args) {\r\n        this.base = base;\r\n        this.args = args;\r\n        this.closestIdx = 0;\r\n        this.isDisposed = false;\r\n        var current = (this.closest = this.root = base);\r\n        var i = 0;\r\n        for (; i < this.args.length - 1; i++) {\r\n            current = current.get(args[i]);\r\n            if (current)\r\n                this.closest = current;\r\n            else\r\n                break;\r\n        }\r\n        this.closestIdx = i;\r\n    }\r\n    DeepMapEntry.prototype.exists = function () {\r\n        this.assertNotDisposed();\r\n        var l = this.args.length;\r\n        return this.closestIdx >= l - 1 && this.closest.has(this.args[l - 1]);\r\n    };\r\n    DeepMapEntry.prototype.get = function () {\r\n        this.assertNotDisposed();\r\n        if (!this.exists())\r\n            throw new Error(\"Entry doesn't exist\");\r\n        return this.closest.get(this.args[this.args.length - 1]);\r\n    };\r\n    DeepMapEntry.prototype.set = function (value) {\r\n        this.assertNotDisposed();\r\n        var l = this.args.length;\r\n        var current = this.closest;\r\n        // create remaining maps\r\n        for (var i = this.closestIdx; i < l - 1; i++) {\r\n            var m = new Map();\r\n            current.set(this.args[i], m);\r\n            current = m;\r\n        }\r\n        this.closestIdx = l - 1;\r\n        this.closest = current;\r\n        current.set(this.args[l - 1], value);\r\n    };\r\n    DeepMapEntry.prototype.delete = function () {\r\n        this.assertNotDisposed();\r\n        if (!this.exists())\r\n            throw new Error(\"Entry doesn't exist\");\r\n        var l = this.args.length;\r\n        this.closest.delete(this.args[l - 1]);\r\n        // clean up remaining maps if needed (reconstruct stack first)\r\n        var c = this.root;\r\n        var maps = [c];\r\n        for (var i = 0; i < l - 1; i++) {\r\n            c = c.get(this.args[i]);\r\n            maps.push(c);\r\n        }\r\n        for (var i = maps.length - 1; i > 0; i--) {\r\n            if (maps[i].size === 0)\r\n                maps[i - 1].delete(this.args[i - 1]);\r\n        }\r\n        this.isDisposed = true;\r\n    };\r\n    DeepMapEntry.prototype.assertNotDisposed = function () {\r\n        // TODO: once this becomes annoying, we should introduce a reset method to re-run the constructor logic\r\n        if (this.isDisposed)\r\n            throw new Error(\"Concurrent modification exception\");\r\n    };\r\n    return DeepMapEntry;\r\n}());\r\n/**\r\n * @private\r\n */\r\nvar DeepMap = /** @class */ (function () {\r\n    function DeepMap() {\r\n        this.store = new Map();\r\n        this.argsLength = -1;\r\n    }\r\n    DeepMap.prototype.entry = function (args) {\r\n        if (this.argsLength === -1)\r\n            this.argsLength = args.length;\r\n        else if (this.argsLength !== args.length)\r\n            throw new Error(\"DeepMap should be used with functions with a consistent length, expected: \" + this.argsLength + \", got: \" + args.length);\r\n        if (this.last)\r\n            this.last.isDisposed = true;\r\n        return (this.last = new DeepMapEntry(this.store, args));\r\n    };\r\n    return DeepMap;\r\n}());\n\nvar __assign$3 = (undefined && undefined.__assign) || function () {\r\n    __assign$3 = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$3.apply(this, arguments);\r\n};\r\n/**\r\n * computedFn takes a function with an arbitrary amount of arguments,\r\n * and memoizes the output of the function based on the arguments passed in.\r\n *\r\n * computedFn(fn) returns a function with the very same signature. There is no limit on the amount of arguments\r\n * that is accepted. However, the amount of arguments must be constant and default arguments are not supported.\r\n *\r\n * By default the output of a function call will only be memoized as long as the\r\n * output is being observed.\r\n *\r\n * The function passes into `computedFn` should be pure, not be an action and only be relying on\r\n * observables.\r\n *\r\n * Setting `keepAlive` to `true` will cause the output to be forcefully cached forever.\r\n * Note that this might introduce memory leaks!\r\n *\r\n * @example\r\n * const store = observable({\r\n    a: 1,\r\n    b: 2,\r\n    c: 3,\r\n    m: computedFn(function(x) {\r\n      return this.a * this.b * x\r\n    })\r\n  })\r\n\r\n  const d = autorun(() => {\r\n    // store.m(3) will be cached as long as this autorun is running\r\n    console.log(store.m(3) * store.c)\r\n  })\r\n *\r\n * @param fn\r\n * @param keepAliveOrOptions\r\n */\r\nfunction computedFn(fn, keepAliveOrOptions) {\r\n    if (keepAliveOrOptions === void 0) { keepAliveOrOptions = false; }\r\n    if (isAction(fn))\r\n        throw new Error(\"computedFn shouldn't be used on actions\");\r\n    var memoWarned = false;\r\n    var i = 0;\r\n    var opts = typeof keepAliveOrOptions === \"boolean\"\r\n        ? { keepAlive: keepAliveOrOptions }\r\n        : keepAliveOrOptions;\r\n    var d = new DeepMap();\r\n    return function () {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var entry = d.entry(args);\r\n        // cache hit, return\r\n        if (entry.exists())\r\n            return entry.get().get();\r\n        // if function is invoked, and its a cache miss without reactive, there is no point in caching...\r\n        if (!opts.keepAlive && !_isComputingDerivation()) {\r\n            if (!memoWarned) {\r\n                console.warn(\"invoking a computedFn from outside an reactive context won't be memoized, unless keepAlive is set\");\r\n                memoWarned = true;\r\n            }\r\n            return fn.apply(this, args);\r\n        }\r\n        // create new entry\r\n        var c = computed(function () {\r\n            return fn.apply(_this, args);\r\n        }, __assign$3(__assign$3({}, opts), { name: \"computedFn(\" + fn.name + \"#\" + ++i + \")\" }));\r\n        entry.set(c);\r\n        // clean up if no longer observed\r\n        if (!opts.keepAlive)\r\n            onBecomeUnobserved(c, function () {\r\n                d.entry(args).delete();\r\n            });\r\n        // return current val\r\n        return c.get();\r\n    };\r\n}\n\nfunction decorateMethodOrField(decoratorName, decorateFn, target, prop, descriptor) {\r\n    if (descriptor) {\r\n        return decorateMethod(decoratorName, decorateFn, prop, descriptor);\r\n    }\r\n    else {\r\n        decorateField(decorateFn, target, prop);\r\n    }\r\n}\r\nfunction decorateMethod(decoratorName, decorateFn, prop, descriptor) {\r\n    if (descriptor.get !== undefined) {\r\n        return fail(decoratorName + \" cannot be used with getters\");\r\n    }\r\n    // babel / typescript\r\n    // @action method() { }\r\n    if (descriptor.value) {\r\n        // typescript\r\n        return {\r\n            value: decorateFn(prop, descriptor.value),\r\n            enumerable: false,\r\n            configurable: true,\r\n            writable: true,\r\n        };\r\n    }\r\n    // babel only: @action method = () => {}\r\n    var initializer = descriptor.initializer;\r\n    return {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        initializer: function () {\r\n            // N.B: we can't immediately invoke initializer; this would be wrong\r\n            return decorateFn(prop, initializer.call(this));\r\n        },\r\n    };\r\n}\r\nfunction decorateField(decorateFn, target, prop) {\r\n    // Simple property that writes on first invocation to the current instance\r\n    Object.defineProperty(target, prop, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        get: function () {\r\n            return undefined;\r\n        },\r\n        set: function (value) {\r\n            addHiddenProp(this, prop, decorateFn(prop, value));\r\n        },\r\n    });\r\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar runId = 0;\r\nvar unfinishedIds = new Set();\r\nvar currentlyActiveIds = new Set();\r\nvar inOrderExecution;\r\n{\r\n    var taskOrderPromise_1 = Promise.resolve();\r\n    var queueMicrotaskPolyfill_1;\r\n    if (typeof queueMicrotask !== \"undefined\") {\r\n        // use real implementation if possible in modern browsers/node\r\n        queueMicrotaskPolyfill_1 = queueMicrotask;\r\n    }\r\n    else if (typeof process !== \"undefined\" && process.nextTick) {\r\n        // fallback to node's process.nextTick in node <= 10\r\n        queueMicrotaskPolyfill_1 = function (cb) {\r\n            process.nextTick(cb);\r\n        };\r\n    }\r\n    else {\r\n        // use setTimeout for old browsers\r\n        queueMicrotaskPolyfill_1 = function (cb) {\r\n            setTimeout(cb, 0);\r\n        };\r\n    }\r\n    var idle_1 = function () {\r\n        return new Promise(function (r) {\r\n            queueMicrotaskPolyfill_1(r);\r\n        });\r\n    };\r\n    // we use this trick to force a proper order of execution\r\n    // even for immediately resolved promises\r\n    inOrderExecution = function () {\r\n        taskOrderPromise_1 = taskOrderPromise_1.then(idle_1);\r\n        return taskOrderPromise_1;\r\n    };\r\n}\r\nvar actionAsyncContextStack = [];\r\nfunction task(value) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var ctx, runId, actionName, args, scope, actionRunInfo, step, nextStep, ret, err_1, actionRunInfo_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    ctx = actionAsyncContextStack[actionAsyncContextStack.length - 1];\r\n                    if (!ctx) {\r\n                        fail$1(\"'actionAsync' context not present when running 'task'. did you await inside an 'actionAsync' without using 'task(promise)'? did you forget to await the task?\");\r\n                    }\r\n                    runId = ctx.runId, actionName = ctx.actionName, args = ctx.args, scope = ctx.scope, actionRunInfo = ctx.actionRunInfo, step = ctx.step;\r\n                    nextStep = step + 1;\r\n                    actionAsyncContextStack.pop();\r\n                    _endAction(actionRunInfo);\r\n                    currentlyActiveIds.delete(runId);\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, 4, 6, 7]);\r\n                    return [4 /*yield*/, value];\r\n                case 2:\r\n                    ret = _a.sent();\r\n                    return [4 /*yield*/, inOrderExecution()];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [2 /*return*/, ret];\r\n                case 4:\r\n                    err_1 = _a.sent();\r\n                    return [4 /*yield*/, inOrderExecution()];\r\n                case 5:\r\n                    _a.sent();\r\n                    throw err_1;\r\n                case 6:\r\n                    // only restart if it not a dangling promise (the action is not yet finished)\r\n                    if (unfinishedIds.has(runId)) {\r\n                        actionRunInfo_1 = _startAction(getActionAsyncName(actionName, runId, nextStep), this, args);\r\n                        actionAsyncContextStack.push({\r\n                            runId: runId,\r\n                            step: nextStep,\r\n                            actionRunInfo: actionRunInfo_1,\r\n                            actionName: actionName,\r\n                            args: args,\r\n                            scope: scope,\r\n                        });\r\n                        currentlyActiveIds.add(runId);\r\n                    }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n// base\r\n/**\r\n * Alternative syntax for async actions, similar to `flow` but more compatible with\r\n * Typescript typings. Not to be confused with `asyncAction`, which is deprecated.\r\n *\r\n * `actionAsync` can be used either as a decorator or as a function.\r\n * It takes an async function that internally must use `await task(promise)` rather than\r\n * the standard `await promise`.\r\n *\r\n * When using the mobx devTools, an asyncAction will emit `action` events with names like:\r\n * * `\"fetchUsers - runid 6 - step 0\"`\r\n * * `\"fetchUsers - runid 6 - step 1\"`\r\n * * `\"fetchUsers - runid 6 - step 2\"`\r\n *\r\n * The `runId` represents the action instance. In other words, if `fetchUsers` is invoked\r\n * multiple times concurrently, the events with the same `runid` belong together.\r\n * The `step` number indicates the code block that is now being executed.\r\n *\r\n * @example\r\n * import {actionAsync, task} from \"mobx-utils\"\r\n *\r\n * let users = []\r\n *\r\n * const fetchUsers = actionAsync(\"fetchUsers\", async (url) => {\r\n *   const start = Date.now()\r\n *   // note the use of task when awaiting!\r\n *   const data = await task(window.fetch(url))\r\n *   users = await task(data.json())\r\n *   return start - Date.now()\r\n * })\r\n *\r\n * const time = await fetchUsers(\"http://users.com\")\r\n * console.log(\"Got users\", users, \"in \", time, \"ms\")\r\n *\r\n * @example\r\n * import {actionAsync, task} from \"mobx-utils\"\r\n *\r\n * mobx.configure({ enforceActions: \"observed\" }) // don't allow state modifications outside actions\r\n *\r\n * class Store {\r\n *   \\@observable githubProjects = []\r\n *   \\@observable = \"pending\" // \"pending\" / \"done\" / \"error\"\r\n *\r\n *   \\@actionAsync\r\n *   async fetchProjects() {\r\n *     this.githubProjects = []\r\n *     this.state = \"pending\"\r\n *     try {\r\n *       // note the use of task when awaiting!\r\n *       const projects = await task(fetchGithubProjectsSomehow())\r\n *       const filteredProjects = somePreprocessing(projects)\r\n *       // the asynchronous blocks will automatically be wrapped actions\r\n *       this.state = \"done\"\r\n *       this.githubProjects = filteredProjects\r\n *     } catch (error) {\r\n *        this.state = \"error\"\r\n *     }\r\n *   }\r\n * }\r\n */\r\nfunction actionAsync(arg1, arg2, arg3) {\r\n    // decorator\r\n    if (typeof arguments[1] === \"string\") {\r\n        return decorateMethodOrField(\"@actionAsync\", function (prop, v) {\r\n            return actionAsyncFn(prop, v);\r\n        }, arg1, arg2, arg3);\r\n    }\r\n    // direct invocation\r\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\r\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\r\n    return actionAsyncFn(actionName, fn);\r\n}\r\nfunction actionAsyncFn(actionName, fn) {\r\n    if (!_startAction || !_endAction) {\r\n        fail$1(\"'actionAsync' requires mobx >=5.13.1 or >=4.13.1\");\r\n    }\r\n    invariant(typeof fn === \"function\", \"'asyncAction' expects a function\");\r\n    if (typeof actionName !== \"string\" || !actionName)\r\n        fail$1(\"actions should have valid names, got: '\" + actionName + \"'\");\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var nextRunId, actionRunInfo, finish, promise, ret, err_2;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        nextRunId = runId++;\r\n                        unfinishedIds.add(nextRunId);\r\n                        actionRunInfo = _startAction(getActionAsyncName(actionName, nextRunId, 0), this, args);\r\n                        actionAsyncContextStack.push({\r\n                            runId: nextRunId,\r\n                            step: 0,\r\n                            actionRunInfo: actionRunInfo,\r\n                            actionName: actionName,\r\n                            args: args,\r\n                            scope: this,\r\n                        });\r\n                        currentlyActiveIds.add(nextRunId);\r\n                        finish = function (err) {\r\n                            unfinishedIds.delete(nextRunId);\r\n                            var ctx = actionAsyncContextStack.pop();\r\n                            if (!ctx || ctx.runId !== nextRunId) {\r\n                                // push it back if invalid\r\n                                if (ctx) {\r\n                                    actionAsyncContextStack.push(ctx);\r\n                                }\r\n                                var msg = \"invalid 'actionAsync' context when finishing action '\" + actionName + \"'.\";\r\n                                if (!ctx) {\r\n                                    msg += \" no action context could be found instead.\";\r\n                                }\r\n                                else {\r\n                                    msg += \" an action context for '\" + ctx.actionName + \"' was found instead.\";\r\n                                }\r\n                                msg +=\r\n                                    \" did you await inside an 'actionAsync' without using 'task(promise)'? did you forget to await the task?\";\r\n                                fail$1(msg);\r\n                            }\r\n                            ctx.actionRunInfo.error = err;\r\n                            _endAction(ctx.actionRunInfo);\r\n                            currentlyActiveIds.delete(nextRunId);\r\n                            if (err) {\r\n                                throw err;\r\n                            }\r\n                        };\r\n                        try {\r\n                            promise = fn.apply(this, args);\r\n                        }\r\n                        catch (err) {\r\n                            finish(err);\r\n                        }\r\n                        // are we done sync? (no task run)\r\n                        if (currentlyActiveIds.has(nextRunId)) {\r\n                            finish(undefined);\r\n                            return [2 /*return*/, promise];\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, promise];\r\n                    case 2:\r\n                        ret = _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_2 = _a.sent();\r\n                        finish(err_2);\r\n                        return [3 /*break*/, 4];\r\n                    case 4:\r\n                        finish(undefined);\r\n                        return [2 /*return*/, ret];\r\n                }\r\n            });\r\n        });\r\n    };\r\n}\r\nfunction getActionAsyncName(actionName, runId, step) {\r\n    return actionName + \" - runid \" + runId + \" - step \" + step;\r\n}\n\nexport { FULFILLED, IDENTITY, NOOP, ObservableGroupMap, PENDING, REJECTED, ViewModel, actionAsync, addHiddenProp, asyncAction, chunkProcessor, computedFn, createTransformer, createViewModel, deepObserve, deprecated, expr, fail$1 as fail, fromPromise, fromResource, fromStream, getAllMethodsAndProperties, invariant, isPromiseBasedObservable, keepAlive, lazyObservable, moveItem, now, queueProcessor, task, toStream, whenAsync, whenWithTimeout };\n"],"sourceRoot":""}